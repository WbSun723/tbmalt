

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tbmalt.physics.dftb &mdash; TBMaLT 0.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=7026087e"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            TBMaLT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">1. Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">2. Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">3. Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">4. Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide.html">5. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">6. Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TBMaLT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tbmalt.physics.dftb</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tbmalt.physics.dftb</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Code associated with carrying out DFTB calculations.&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.ml.calculator</span><span class="w"> </span><span class="kn">import</span> <span class="n">Calculator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.ml.integralfeeds</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntegralFeed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">OrbitalInfo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.physics.dftb.feeds</span><span class="w"> </span><span class="kn">import</span> <span class="n">Feed</span><span class="p">,</span> <span class="n">SkfOccupationFeed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.physics.filling</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">fermi_search</span><span class="p">,</span> <span class="n">fermi_smearing</span><span class="p">,</span> <span class="n">gaussian_smearing</span><span class="p">,</span> <span class="n">entropy_term</span><span class="p">,</span>
    <span class="n">aufbau_filling</span><span class="p">,</span> <span class="n">Scheme</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common.maths</span><span class="w"> </span><span class="kn">import</span> <span class="n">eighb</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.physics.dftb.coulomb</span><span class="w"> </span><span class="kn">import</span> <span class="n">build_coulomb_matrix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.physics.dftb.gamma</span><span class="w"> </span><span class="kn">import</span> <span class="n">build_gamma_matrix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.physics.dftb.properties</span><span class="w"> </span><span class="kn">import</span> <span class="n">dos</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">prepeat_interleave</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">float_like</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common.maths.mixers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Simple</span><span class="p">,</span> <span class="n">Anderson</span><span class="p">,</span> <span class="n">Mixer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.data.units</span><span class="w"> </span><span class="kn">import</span> <span class="n">energy_units</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConvergenceError</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>


<div class="viewcode-block" id="mulliken">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.mulliken.html#tbmalt.physics.dftb.mulliken">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mulliken</span><span class="p">(</span>
        <span class="n">rho</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">OrbitalInfo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">resolution</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="s1">&#39;shell&#39;</span><span class="p">,</span> <span class="s1">&#39;orbital&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Mulliken population analysis.</span>

<span class="sd">    By default, orbital resolved populations are returned, however, passing the</span>
<span class="sd">    associated orbs instance will produce atom or shell resolved populations</span>
<span class="sd">    depending on the orbs instance&#39;s `shell_resolved` attribute (the behavior</span>
<span class="sd">    of which can be overridden via the ``resolution`` argument).</span>

<span class="sd">    Arguments:</span>
<span class="sd">        rho: density matrix.</span>
<span class="sd">        S: overlap matrix.</span>
<span class="sd">        orbs: a `OrbitalInfo` instance may be specified to enable atom/shell</span>
<span class="sd">            resolved populations. If omitted, populations will be orbital</span>
<span class="sd">            resolved. [DEFAULT=None]</span>
<span class="sd">        resolution: can be specified to override the degree of resolution</span>
<span class="sd">            defined by the ``orbs`` instance, available options are:</span>

<span class="sd">                - &quot;atom&quot;: atom resolved</span>
<span class="sd">                - &quot;shell&quot;: shell resolved</span>
<span class="sd">                - &quot;orbital&quot;: orbital resolved</span>

<span class="sd">            If unspecified, this will default to the resolution defined by the</span>
<span class="sd">            `orbs.shell_resolved` attribute. This is only valid when ``orbs``</span>
<span class="sd">            is also specified. [DEFAULT=None]</span>

<span class="sd">    Returns:</span>
<span class="sd">        q: mulliken populations.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: if ``resolution`` is specified in absence of ``orbs``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;&quot;resolution&quot; overrides default behaviour associated with the &#39;</span>
            <span class="s1">&#39;&quot;orbs&quot; object</span><span class="se">\&#39;</span><span class="s1">s &quot;shell_resolved&quot; attribute. Thus it cannot be &#39;</span>
            <span class="s1">&#39;specified in absence of the &quot;orbs&quot; argument.&#39;</span><span class="p">)</span>

    <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span> <span class="o">*</span> <span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Calculate the per-orbital Mulliken populations</span>
    <span class="k">if</span> <span class="n">orbs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Resolve to per-shell/atom if instructed to</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">res_matrix_shape</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">on_res</span>
        <span class="k">elif</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;atom&#39;</span><span class="p">:</span>
            <span class="n">size</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">atomic_matrix_shape</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">on_atoms</span>
        <span class="k">elif</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;shell&#39;</span><span class="p">:</span>
            <span class="n">size</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_matrix_shape</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">on_shells</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unknown resolution&quot;</span><span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">rho</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rho</span><span class="o">.</span><span class="n">dtype</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">scatter_add_</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ind</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">q</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">q</span></div>



<div class="viewcode-block" id="Dftb1">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.Dftb1.html#tbmalt.physics.dftb.Dftb1">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Dftb1</span><span class="p">(</span><span class="n">Calculator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Density-functional tight-binding theory method.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        h_feed: this feed provides the Slater-Koster based integrals used to</span>
<span class="sd">            construct Hamiltonian matrix.</span>
<span class="sd">        s_feed: this feed provides the Slater-Koster based integrals used to</span>
<span class="sd">            construct overlap matrix.</span>
<span class="sd">        o_feed: this feed provides the angular-momenta resolved occupancies</span>
<span class="sd">            for the requested species.</span>
<span class="sd">        r_feed: this feed describes the repulsive interaction.[DEFAULT=`None`]</span>
<span class="sd">        filling_temp: Electronic temperature used to calculate Fermi-energy.</span>
<span class="sd">            [DEFAULT=0.0]</span>
<span class="sd">        filling_scheme: The scheme used for finite temperature broadening.</span>
<span class="sd">            There are two broadening methods, Fermi-Dirac broadening and</span>
<span class="sd">            Gaussian broadening, supported in TBMaLT. [DEFAULT=&quot;fermi&quot;]</span>

<span class="sd">    Attributes:</span>
<span class="sd">        rho: density matrix.</span>
<span class="sd">        eig_values: eigen values.</span>
<span class="sd">        eig_vectors: eigen vectors.</span>

<span class="sd">    Notes:</span>
<span class="sd">        Currently energies and occupancies are not scaled correctly. Occupancies</span>
<span class="sd">        and band energies need to be scaled based on whether or not they are i)</span>
<span class="sd">        spin-polarised or spin-unpolarised, ii) have a fixed fermi level for</span>
<span class="sd">        each spin channel or a common one across two colinear spin channels,</span>
<span class="sd">        iii) whether k-points are present or not. See the subroutine named</span>
<span class="sd">        &quot;getFillingsAndBandEnergies&quot; of the file &quot;dftb/lib_dftbplus/main.F90&quot;</span>
<span class="sd">        in DFTB+ for examples.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt import OrbitalInfo, Geometry</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import SkFeed, SkfOccupationFeed</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb import Dftb1</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.tools.downloaders import download_dftb_parameter_set</span>
<span class="sd">        &gt;&gt;&gt; from ase.build import molecule</span>
<span class="sd">        &gt;&gt;&gt; torch.set_default_dtype(torch.float64)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Download the auorg-1-1 parameter set</span>
<span class="sd">        &gt;&gt;&gt; url = &#39;https://github.com/dftbparams/auorg/releases/download/v1.1.0/auorg-1-1.tar.xz&#39;</span>
<span class="sd">        &gt;&gt;&gt; path = &quot;auorg.h5&quot;</span>
<span class="sd">        &gt;&gt;&gt; download_dftb_parameter_set(url, path)</span>
<span class="sd">        &gt;&gt;&gt; # Preparation of system(s) to calculate</span>
<span class="sd">        &gt;&gt;&gt; # Single system</span>
<span class="sd">        &gt;&gt;&gt; geos = Geometry.from_ase_atoms(molecule(&#39;CH4&#39;))</span>
<span class="sd">        &gt;&gt;&gt; orbs_s = OrbitalInfo(geos.atomic_numbers, shell_dict={1: [0], 6: [0, 1]})</span>
<span class="sd">        &gt;&gt;&gt; # Batch systems</span>
<span class="sd">        &gt;&gt;&gt; geob = Geometry.from_ase_atoms([molecule(&#39;H2O&#39;), molecule(&#39;CH4&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; orbs_b = OrbitalInfo(geob.atomic_numbers, shell_dict={</span>
<span class="sd">        ...     1: [0], 6: [0, 1], 8: [0, 1]})</span>
<span class="sd">        &gt;&gt;&gt; # Definition of feeds</span>
<span class="sd">        &gt;&gt;&gt; h_feed = SkFeed.from_database(path, [1, 6, 8], &#39;hamiltonian&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s_feed = SkFeed.from_database(path, [1, 6, 8], &#39;overlap&#39;)</span>
<span class="sd">        &gt;&gt;&gt; o_feed = SkfOccupationFeed.from_database(path, [1, 6, 8])</span>
<span class="sd">        &gt;&gt;&gt; # Create Dftb1 calculator instances</span>
<span class="sd">        &gt;&gt;&gt; dftb = Dftb1(h_feed, s_feed, o_feed, filling_temp=0.0036749324)</span>
<span class="sd">        &gt;&gt;&gt; # Run DFTB1 calculation(s)</span>
<span class="sd">        &gt;&gt;&gt; dftb(geos, orbs_s)</span>
<span class="sd">        &gt;&gt;&gt; print(dftb.q_final_atomic)</span>
<span class="sd">        tensor([4.3591, 0.9102, 0.9102, 0.9102, 0.9102])</span>
<span class="sd">        &gt;&gt;&gt; dftb(geob, orbs_b)</span>
<span class="sd">        &gt;&gt;&gt; print(dftb.q_final_atomic)</span>
<span class="sd">        tensor([[6.7552, 0.6224, 0.6224, 0.0000, 0.0000],</span>
<span class="sd">                [4.3591, 0.9102, 0.9102, 0.9102, 0.9102]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">h_feed</span><span class="p">:</span> <span class="n">IntegralFeed</span><span class="p">,</span> <span class="n">s_feed</span><span class="p">:</span> <span class="n">IntegralFeed</span><span class="p">,</span> <span class="n">o_feed</span><span class="p">:</span> <span class="n">Feed</span><span class="p">,</span>
            <span class="n">r_feed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Feed</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">filling_temp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="n">filling_scheme</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fermi&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">h_feed</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">h_feed</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Calculator Feeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h_feed</span> <span class="o">=</span> <span class="n">h_feed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_feed</span> <span class="o">=</span> <span class="n">s_feed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o_feed</span> <span class="o">=</span> <span class="n">o_feed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_feed</span> <span class="o">=</span> <span class="n">r_feed</span>

        <span class="n">device_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">device</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">h_feed</span><span class="p">,</span> <span class="n">s_feed</span><span class="p">,</span> <span class="n">o_feed</span><span class="p">,</span> <span class="n">r_feed</span><span class="p">]</span>
                       <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">device_list</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All `Feeds` must be on the same device&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Calculator Settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span> <span class="o">=</span> <span class="n">filling_temp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fermi&#39;</span><span class="p">:</span> <span class="n">fermi_smearing</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span> <span class="n">gaussian_smearing</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}[</span><span class="n">filling_scheme</span><span class="p">]</span>

        <span class="c1"># Optional keyword arguments can be passed through to the `eighb`</span>
        <span class="c1"># solver via the `_solver_settings` dictionary argument.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solver_settings</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;eigen_solver_settings&#39;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overlap matrix&quot;&quot;&quot;</span>

        <span class="c1"># Check to see if the overlap matrix has already been constructed. If</span>
        <span class="c1"># not then construct it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_feed</span><span class="o">.</span><span class="n">matrix_from_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Return the cached overlap matrix.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span>

    <span class="nd">@overlap</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hamiltonian matrix&quot;&quot;&quot;</span>

        <span class="c1"># See `Dftb1.overlap` for an explanation of what this code does.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_feed</span><span class="o">.</span><span class="n">matrix_from_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span>

    <span class="nd">@hamiltonian</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial orbital populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o_feed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_final</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final orbital populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mulliken</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delta orbital populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_final</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_zero_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial shell-wise populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">shell_matrix_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">scatter_add_</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">on_shells</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_final_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final shell-wise populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mulliken</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span> <span class="s1">&#39;shell&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_delta_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delta shell-wise populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_final_shells</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_shells</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_zero_atomic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial atomic populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">atomic_matrix_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">scatter_add_</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">on_atoms</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_final_atomic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final atomic populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mulliken</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_delta_atomic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delta atomic populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_final_atomic</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_atomic</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_zero_res</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial charges, atom or shell resolved according to `OrbitalInfo`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">shell_resolved</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_shells</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_atomic</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dipole</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dipole moments.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_delta_atomic</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_electrons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of electrons&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">occupancy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Occupancies of each state&quot;&quot;&quot;</span>

        <span class="c1"># Note that this scale factor assumes spin-restricted and will need to</span>
        <span class="c1"># be refactored when implementing spin-unrestricted calculations.</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">2.0</span>

        <span class="c1"># If finite temperature is active then use the appropriate smearing</span>
        <span class="c1"># method.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_energy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span><span class="p">,</span>
                <span class="n">e_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale_factor</span>
        <span class="c1"># Otherwise just fill according to the Aufbau principle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">aufbau_filling</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span>
                <span class="n">e_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale_factor</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fermi_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fermi energy&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fermi_search</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span><span class="p">,</span>
            <span class="c1"># Pass the e_mask argument, but only if required.</span>
            <span class="n">e_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">band_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Band structure energy&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...i,...i-&gt;...&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">band_free_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Band free energy; i.e. E_band-TS&quot;&quot;&quot;</span>
        <span class="c1"># Note that this scale factor assumes spin-restricted and will need to</span>
        <span class="c1"># be refactored when implementing spin-unrestricted calculations.</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_energy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The function `entropy_term` yields the &quot;TS&quot; term</span>
            <span class="n">energy</span> <span class="o">-=</span> <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">entropy_term</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_energy</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span><span class="p">,</span> <span class="n">e_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">energy</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">repulsive_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Repulsive energy; zero in the absence of a repulsive feed&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_feed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_feed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total system energy&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_energy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">repulsive_energy</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mermin_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mermin free energy; i.e. E_total-TS&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_free_energy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">repulsive_energy</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">homo_lumo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Highest occupied and lowest unoccupied energy level in unit hartree&quot;&quot;&quot;</span>
        <span class="c1"># Number of occupied states, spin-unpolarized case with threshold &gt; 1.0</span>
        <span class="n">nocc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Check if HOMO&amp;LUMO well defined</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">nocc</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Warning: HOMO&amp;LUMO are not defined properly!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mask of HOMO and LUMO</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nocc</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span>
                    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nocc</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>
            <span class="n">homo_lumo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">homo_lumo</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">homo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Highest occupied energy level in unit hartree&quot;&quot;&quot;</span>
        <span class="c1"># Locate HOMO index, spin-unpolarized case with threshold &gt; 1.0</span>
        <span class="n">i_homo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Check if any system is not occupied at all</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i_homo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;HOMO is not defined properly!&quot;</span><span class="p">)</span>
        <span class="n">homo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">i_homo</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">i_homo</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">homo</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lumo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lowest unoccupied energy level in unit hartree&quot;&quot;&quot;</span>
        <span class="c1"># Locate LUMO index, spin-unpolarized case with threshold &gt; 1.0</span>
        <span class="n">i_lumo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Check if any system is fully occupied</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i_lumo</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;System is fully occupied. LUMO is not defined properly!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Number of real states in batch</span>
            <span class="n">n_real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">on_atoms</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Check if the last real state is occupied</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">n_real</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;System is fully occupied. LUMO is not defined properly!&#39;</span><span class="p">)</span>

        <span class="n">lumo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">i_lumo</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">i_lumo</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lumo</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dos_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">energy_units</span><span class="p">[</span><span class="s1">&#39;ev&#39;</span><span class="p">],</span> <span class="n">grid</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Energy distribution of (p)DOS in unit hartree&quot;&quot;&quot;</span>
        <span class="n">e_min</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">ext</span>
        <span class="n">e_max</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="n">ext</span>
        <span class="n">dos_energy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">dos_energy</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Electronic density of states&quot;&quot;&quot;</span>
        <span class="c1"># Mask to remove padding values.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">energy_units</span><span class="p">[</span><span class="s1">&#39;ev&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dos_energy</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Atomic forces&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Forces are computed via the PyTorch auto-grad engine, thus &quot;</span>
                <span class="s2">&quot;the positions tensor must be differentiable, i.e. &quot;</span>
                <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">Geometry.positions.requires_grad = True</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">gradient</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mermin_energy</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">gradient</span>

<div class="viewcode-block" id="Dftb1.reset">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.Dftb1.html#tbmalt.physics.dftb.Dftb1.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset all attributes and cached properties.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_vectors</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Dftb1.forward">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.Dftb1.html#tbmalt.physics.dftb.Dftb1.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span>
                <span class="n">cache</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the non-SCC DFTB calculation.</span>

<span class="sd">        This method triggers the execution of the non-self-consistent-charge</span>
<span class="sd">        density functional tight binding theory calculation. Once complete</span>
<span class="sd">        this will return the total system energy.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            geometry: System(s) upon which the calculation is to be run.</span>
<span class="sd">            orbs: Orbital information associated with said system(s).</span>
<span class="sd">            cache: Currently, the `Dftb1` calculator does not make use of the</span>
<span class="sd">                `cache` argument.</span>

<span class="sd">        Returns:</span>
<span class="sd">            energy: Total energy of the target system(s). If repulsive</span>
<span class="sd">                interactions are not considered, i.e. the repulsion feed is</span>
<span class="sd">                omitted, then this will be the band structure energy. If</span>
<span class="sd">                finite temperature is active then this will be the Mermin</span>
<span class="sd">                free energy.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset the calculator and assign the `geometry` &amp; `orbs` attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orbs</span> <span class="o">=</span> <span class="n">orbs</span>

        <span class="c1"># Construct the Hamiltonian &amp; overlap matrices then perform the eigen</span>
        <span class="c1"># decomposition to get the eigen values and vectors.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_vectors</span> <span class="o">=</span> <span class="n">eighb</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_solver_settings</span><span class="p">)</span>

        <span class="c1"># Then construct the density matrix.</span>
        <span class="n">s_occs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>  <span class="c1"># Scaled occupancy values</span>
            <span class="s1">&#39;...i,...ji-&gt;...ji&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_vectors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">s_occs</span> <span class="o">@</span> <span class="n">s_occs</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="c1"># Calculate and return the total system energy, taking into account</span>
        <span class="c1"># the entropy term as and when necessary.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mermin_energy</span></div>
</div>



<div class="viewcode-block" id="Dftb2">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.Dftb2.html#tbmalt.physics.dftb.Dftb2">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Dftb2</span><span class="p">(</span><span class="n">Calculator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Self-consistent-charge density-functional tight-binding method.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        h_feed: this feed provides the Slater-Koster based integrals used to</span>
<span class="sd">            construct Hamiltonian matrix.</span>
<span class="sd">        s_feed: this feed provides the Slater-Koster based integrals used to</span>
<span class="sd">            construct overlap matrix.</span>
<span class="sd">        o_feed: this feed provides the angular-momenta resolved occupancies</span>
<span class="sd">            for the requested species.</span>
<span class="sd">        u_feed: this feed provides the Hubbard-U values as needed to construct</span>
<span class="sd">            the gamma matrix. This must be a `Feed` type object which when</span>
<span class="sd">            provided with a `OrbitalInfo` object returns the Hubbard-U values</span>
<span class="sd">            for the target system.</span>
<span class="sd">        r_feed: this feed describes the repulsive interaction.[DEFAULT=`None`]</span>
<span class="sd">        filling_temp: Electronic temperature used to calculate Fermi-energy.</span>
<span class="sd">            [DEFAULT=0.0]</span>
<span class="sd">        filling_scheme: The scheme used for finite temperature broadening.</span>
<span class="sd">            There are two broadening methods, Fermi-Dirac broadening and</span>
<span class="sd">            Gaussian broadening, supported in TBMaLT. [DEFAULT=&quot;fermi&quot;]</span>
<span class="sd">        grad_mode: controls gradient mode used when running the SCC</span>
<span class="sd">            cycle. Available options are [DEFAULT=&quot;last_step&quot;]:</span>

<span class="sd">                - &quot;direct&quot;:</span>
<span class="sd">                    Run the SCC cycle without any special treatment.</span>
<span class="sd">                - &quot;last_step&quot;:</span>
<span class="sd">                    Run the SCC cycle outside the purview of the PyTorch graph</span>
<span class="sd">                    to obtain the converged charges. Then run a single SCC step</span>
<span class="sd">                    within the graph using the converged charges as the initial</span>
<span class="sd">                    &quot;guess&quot;. Gradients obtained via the &quot;last_step&quot; approach are</span>
<span class="sd">                    inexact. While such gradients are commonly a good enough</span>
<span class="sd">                    approximation for many cases they are not as accurate as</span>
<span class="sd">                    either the &quot;direct&quot; or &quot;implicit&quot; gradient modes.</span>
<span class="sd">                - &quot;implicit&quot;:</span>
<span class="sd">                    Uses implicit function theorem to accurately and memory</span>
<span class="sd">                    efficiently compute the derivative. This requires the use</span>
<span class="sd">                    of an iterative solver. By default, the solver will employ</span>
<span class="sd">                    the same mixer provided for the SCC cycle, `DFTB2.mixer`.</span>
<span class="sd">                    It is critical to note that the accuracy of the gradients</span>
<span class="sd">                    produced by the implicit method is directly tied to the</span>
<span class="sd">                    tolerance and stability of the mixer. As such a different</span>
<span class="sd">                    dedicated mixer can be supplied via the ``implicit_mixer``</span>
<span class="sd">                    argument.</span>

<span class="sd">        implicit_mixer: Dedicated mixer to be used by the implicit solver if</span>
<span class="sd">            using the &quot;implicit&quot; ``grad_mode`` option. This is only used</span>
<span class="sd">            when the &quot;implicit&quot; option is set via ``grad_mode``. If not set</span>
<span class="sd">            then the standard SCC mixer will be used.</span>
<span class="sd">        max_scc_iter: maximum permitted number of SCC iterations. If one or</span>
<span class="sd">            more system fail to converge within ``max_scc_iter`` cycles then a</span>
<span class="sd">            convergence error will be raised; unless the ``suppress_scc_error``</span>
<span class="sd">            flag has been set. [DEFAULT=200]</span>
<span class="sd">        mixer: specifies the charge mixing scheme to be used. Providing the</span>
<span class="sd">            strings &quot;simple&quot; and &quot;anderson&quot; will result in their respectively</span>
<span class="sd">            named mixing schemes being used. Initialised `Mixer` class objects</span>
<span class="sd">            may also be provided directly.</span>

<span class="sd">    Keyword Arguments:</span>
<span class="sd">        suppress_scc_error: if True, convergence errors will be suppressed and</span>
<span class="sd">            the calculation will proceed with as normal. This is of use during</span>
<span class="sd">            fitting when operating on large batches. This way if most systems</span>
<span class="sd">            converge but one does not then it can just be ignored rather than</span>
<span class="sd">            ending the program. Unconverged systems can be identified via the</span>
<span class="sd">            ``converged`` attribute. [DEFAULT=False]</span>
<span class="sd">        gamma_scheme: scheme used to construct the gamma matrix. This may be</span>
<span class="sd">            either &quot;exponential&quot; or &quot;gaussian&quot;. [DEFAULT=&quot;exponential&quot;]</span>
<span class="sd">        coulomb_scheme: scheme used to construct the coulomb matrix. This may</span>
<span class="sd">            be either &quot;search&quot; or &quot;experience&quot;. [DEFAULT=&quot;search&quot;]</span>

<span class="sd">    Attributes:</span>
<span class="sd">        converged: a tensor of booleans indicating which systems have and</span>
<span class="sd">            have not converged (True if converged). This can be used during</span>
<span class="sd">            training, alongside `suppress_scc_error`, to allow unconverged</span>
<span class="sd">            systems to be omitted from the final loss calculation; as so to</span>
<span class="sd">            prevent introducing unnecessary instabilities.</span>
<span class="sd">        mixer: a `Mixer` type class instance used during the SCC cycle to</span>
<span class="sd">            perform charge mixing.</span>
<span class="sd">        rho: density matrix.</span>
<span class="sd">        eig_values: eigen values.</span>
<span class="sd">        eig_vectors: eigen vectors.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt import OrbitalInfo, Geometry</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import HubbardFeed, SkFeed, SkfOccupationFeed</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb import Dftb2</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.tools.downloaders import download_dftb_parameter_set</span>
<span class="sd">        &gt;&gt;&gt; from ase.build import molecule</span>
<span class="sd">        &gt;&gt;&gt; torch.set_default_dtype(torch.float64)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Download the auorg-1-1 parameter set</span>
<span class="sd">        &gt;&gt;&gt; url = &#39;https://github.com/dftbparams/auorg/releases/download/v1.1.0/auorg-1-1.tar.xz&#39;</span>
<span class="sd">        &gt;&gt;&gt; path = &quot;auorg.h5&quot;</span>
<span class="sd">        &gt;&gt;&gt; download_dftb_parameter_set(url, path)</span>
<span class="sd">        &gt;&gt;&gt; # Preparation of system(s) to calculate</span>
<span class="sd">        &gt;&gt;&gt; # Single system</span>
<span class="sd">        &gt;&gt;&gt; geos = Geometry.from_ase_atoms(molecule(&#39;CH4&#39;))</span>
<span class="sd">        &gt;&gt;&gt; orbs_s = OrbitalInfo(geos.atomic_numbers, shell_dict={1: [0], 6: [0, 1]})</span>
<span class="sd">        &gt;&gt;&gt; # Batch systems</span>
<span class="sd">        &gt;&gt;&gt; geob = Geometry.from_ase_atoms([molecule(&#39;H2O&#39;), molecule(&#39;CH4&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; orbs_b = OrbitalInfo(geob.atomic_numbers, shell_dict={</span>
<span class="sd">        ...     1: [0], 6: [0, 1], 8: [0, 1]})</span>
<span class="sd">        &gt;&gt;&gt; # Single periodic system</span>
<span class="sd">        &gt;&gt;&gt; geop = Geometry(</span>
<span class="sd">        ...     torch.tensor([6, 1, 1, 1, 1]),</span>
<span class="sd">        ...     torch.tensor([[3.0, 3.0, 3.0],</span>
<span class="sd">        ...                   [3.6, 3.6, 3.6],</span>
<span class="sd">        ...                   [2.4, 3.6, 3.6],</span>
<span class="sd">        ...                   [3.6, 2.4, 3.6],</span>
<span class="sd">        ...                   [3.6, 3.6, 2.4]]),</span>
<span class="sd">        ...     torch.tensor([[4.0, 4.0, 0.0],</span>
<span class="sd">        ...                   [5.0, 0.0, 5.0],</span>
<span class="sd">        ...                   [0.0, 6.0, 6.0]]),</span>
<span class="sd">        ...     units=&#39;a&#39;, cutoff=torch.tensor([9.98]))</span>
<span class="sd">        &gt;&gt;&gt; orbs_p = OrbitalInfo(geop.atomic_numbers, shell_dict={1: [0], 6: [0, 1]})</span>
<span class="sd">        &gt;&gt;&gt; # Definition of feeds</span>
<span class="sd">        &gt;&gt;&gt; h_feed = SkFeed.from_database(path, [1, 6, 8], &#39;hamiltonian&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s_feed = SkFeed.from_database(path, [1, 6, 8], &#39;overlap&#39;)</span>
<span class="sd">        &gt;&gt;&gt; o_feed = SkfOccupationFeed.from_database(path, [1, 6, 8])</span>
<span class="sd">        &gt;&gt;&gt; u_feed = HubbardFeed.from_database(path, [1, 6, 8])</span>
<span class="sd">        &gt;&gt;&gt; # Run DFTB2 calculation</span>
<span class="sd">        &gt;&gt;&gt; mix_params = {&#39;mix_param&#39;: 0.2, &#39;init_mix_param&#39;: 0.2,</span>
<span class="sd">        ...               &#39;generations&#39;: 3, &#39;tolerance&#39;: 1e-10}</span>
<span class="sd">        &gt;&gt;&gt; dftb2 = Dftb2(h_feed, s_feed, o_feed, u_feed,</span>
<span class="sd">        ...               filling_temp=0.0036749324, mix_params=mix_params)</span>
<span class="sd">        &gt;&gt;&gt; dftb2(geos, orbs_s)</span>
<span class="sd">        &gt;&gt;&gt; print(dftb2.q_final_atomic)</span>
<span class="sd">        tensor([4.3054, 0.9237, 0.9237, 0.9237, 0.9237])</span>
<span class="sd">        &gt;&gt;&gt; dftb2(geob, orbs_b)</span>
<span class="sd">        &gt;&gt;&gt; print(dftb2.q_final_atomic)</span>
<span class="sd">        tensor([[6.5856, 0.7072, 0.7072, 0.0000, 0.0000],</span>
<span class="sd">                [4.3054, 0.9237, 0.9237, 0.9237, 0.9237]])</span>
<span class="sd">        &gt;&gt;&gt; dftb2(geop, orbs_p)</span>
<span class="sd">        &gt;&gt;&gt; print(dftb2.q_final_atomic)</span>
<span class="sd">        tensor([4.6124, 0.8332, 0.8527, 0.8518, 0.8499])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">h_feed</span><span class="p">:</span> <span class="n">IntegralFeed</span><span class="p">,</span> <span class="n">s_feed</span><span class="p">:</span> <span class="n">IntegralFeed</span><span class="p">,</span> <span class="n">o_feed</span><span class="p">:</span> <span class="n">Feed</span><span class="p">,</span>
            <span class="n">u_feed</span><span class="p">:</span> <span class="n">Feed</span><span class="p">,</span> <span class="n">r_feed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Feed</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">filling_temp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="n">filling_scheme</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fermi&#39;</span><span class="p">,</span>
            <span class="n">grad_mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;direct&quot;</span><span class="p">,</span> <span class="s2">&quot;last_step&quot;</span><span class="p">,</span> <span class="s2">&quot;implicit&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;last_step&quot;</span><span class="p">,</span>
            <span class="n">implicit_mixer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mixer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">max_scc_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
            <span class="n">mixer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mixer</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;anderson&#39;</span><span class="p">,</span> <span class="s1">&#39;simple&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;anderson&#39;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">h_feed</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">h_feed</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Calculator Feeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h_feed</span> <span class="o">=</span> <span class="n">h_feed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_feed</span> <span class="o">=</span> <span class="n">s_feed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">o_feed</span> <span class="o">=</span> <span class="n">o_feed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_feed</span> <span class="o">=</span> <span class="n">u_feed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_feed</span> <span class="o">=</span> <span class="n">r_feed</span>

        <span class="n">device_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">d</span><span class="o">.</span><span class="n">device</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="n">h_feed</span><span class="p">,</span> <span class="n">s_feed</span><span class="p">,</span> <span class="n">o_feed</span><span class="p">,</span> <span class="n">u_feed</span><span class="p">,</span> <span class="n">r_feed</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">device_list</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All `Feeds` must be on the same device&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_core_hamiltonian</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converged</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Calculator Settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span> <span class="o">=</span> <span class="n">filling_temp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fermi&#39;</span><span class="p">:</span> <span class="n">fermi_smearing</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span> <span class="n">gaussian_smearing</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}[</span><span class="n">filling_scheme</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grad_mode</span> <span class="o">=</span> <span class="n">grad_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">implicit_mixer</span> <span class="o">=</span> <span class="n">implicit_mixer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_scc_iter</span> <span class="o">=</span> <span class="n">max_scc_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suppress_scc_error</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;suppress_scc_error&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_scheme</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gamma_scheme&#39;</span><span class="p">,</span> <span class="s1">&#39;exponential&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coulomb_scheme</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coulomb_scheme&#39;</span><span class="p">,</span> <span class="s1">&#39;search&#39;</span><span class="p">)</span>

        <span class="c1"># If no pre-initialised was provided then construct one.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mixer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">mixer</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;anderson&#39;</span><span class="p">:</span> <span class="n">Anderson</span><span class="p">,</span> <span class="s1">&#39;simple&#39;</span><span class="p">:</span> <span class="n">Simple</span><span class="p">}[</span>
                <span class="n">mixer</span><span class="o">.</span><span class="n">lower</span><span class="p">()](</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mix_params&#39;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mixer</span> <span class="o">=</span> <span class="n">mixer</span>

        <span class="c1"># Optional keyword arguments can be passed through to the `eighb`</span>
        <span class="c1"># solver via the `_solver_settings` dictionary argument.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_solver_settings</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;eigen_solver_settings&#39;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">if</span> <span class="n">grad_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;direct&quot;</span><span class="p">,</span> <span class="s2">&quot;last_step&quot;</span><span class="p">,</span> <span class="s2">&quot;implicit&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="si">{</span><span class="n">grad_mode</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2"> does not correspond to a known gradient mode.&quot;</span>
                <span class="s2">&quot; Valid options are </span><span class="se">\&quot;</span><span class="s2">direct</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">last_step</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">implicit</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overlap matrix as constructed by the supplied `s_feed`&quot;&quot;&quot;</span>

        <span class="c1"># Check to see if the overlap matrix has already been constructed. If</span>
        <span class="c1"># not then construct it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_feed</span><span class="o">.</span><span class="n">matrix_from_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Return the cached overlap matrix.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span>

    <span class="nd">@overlap</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second order Hamiltonian matrix as produced via the SCC cycle&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span>

    <span class="nd">@hamiltonian</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">core_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First order core Hamiltonian matrix as built by the `h_feed` entity&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core_hamiltonian</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_core_hamiltonian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_feed</span><span class="o">.</span><span class="n">matrix_from_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_core_hamiltonian</span>

    <span class="nd">@core_hamiltonian</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">core_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_core_hamiltonian</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gamma matrix constructed via the specified scheme using the Hubbard-U values produced by the `u_feed`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span> <span class="o">=</span> <span class="n">build_gamma_matrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invr</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_feed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_scheme</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span>

    <span class="nd">@gamma</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial orbital populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">o_feed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_final</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final orbital populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mulliken</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delta orbital populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_final</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_zero_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial shell-wise populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">shell_matrix_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">scatter_add_</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">on_shells</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_final_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final shell-wise populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mulliken</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span> <span class="s1">&#39;shell&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_delta_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delta shell-wise populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_final_shells</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_shells</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_zero_atomic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial atomic populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">atomic_matrix_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">scatter_add_</span><span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">on_atoms</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_final_atomic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final atomic populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mulliken</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_delta_atomic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delta atomic populations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_final_atomic</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_atomic</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_zero_res</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial charges, atom or shell resolved according to `OrbitalInfo`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">shell_resolved</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_shells</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_atomic</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dipole</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dipole moments.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_delta_atomic</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_electrons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of electrons&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">occupancy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Occupancies of each state&quot;&quot;&quot;</span>

        <span class="c1"># Note that this scale factor assumes spin-restricted and will need to</span>
        <span class="c1"># be refactored when implementing spin-unrestricted calculations.</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">2.0</span>

        <span class="c1"># If finite temperature is active then use the appropriate smearing</span>
        <span class="c1"># method.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_energy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span><span class="p">,</span>
                <span class="n">e_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale_factor</span>
        <span class="c1"># Otherwise just fill according to the Aufbau principle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">aufbau_filling</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span>
                <span class="n">e_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale_factor</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fermi_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fermi energy&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fermi_search</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span><span class="p">,</span>
            <span class="c1"># Pass the e_mask argument, but only if required.</span>
            <span class="n">e_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">band_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Band structure energy, including SCC contributions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...i,...i-&gt;...&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">core_band_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Core band structure energy, excluding SCC contributions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_hamiltonian</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">band_free_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Band free energy including SCC contributions; i.e. E_band-TS&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_energy</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_entropy_term</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">core_band_free_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Core band free energy, excluding SCC contributions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_band_energy</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_entropy_term</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_entropy_term</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Note that this scale factor assumes spin-restricted and will need to</span>
        <span class="c1"># be refactored when implementing spin-unrestricted calculations.</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The function `entropy_term` yields the &quot;TS&quot; term</span>
            <span class="k">return</span> <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">entropy_term</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_energy</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span><span class="p">,</span> <span class="n">e_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scc_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Energy contribution from charge fluctuation via the SCC cycle&quot;&quot;&quot;</span>
        <span class="n">q_delta</span> <span class="o">=</span> <span class="n">mulliken</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_res</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...i,...ij-&gt;...j&#39;</span><span class="p">,</span> <span class="n">q_delta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">shifts</span> <span class="o">*</span> <span class="n">q_delta</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">repulsive_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Repulsive energy; zero in the absence of a repulsive feed&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_feed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_feed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total system energy&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_band_energy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">scc_energy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">repulsive_energy</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mermin_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mermin free energy; i.e. E_total-TS&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_band_free_energy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">scc_energy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">repulsive_energy</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">homo_lumo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Highest occupied and lowest unoccupied energy level in unit hartree&quot;&quot;&quot;</span>
        <span class="c1"># Number of occupied states, spin-unpolarized case with threshold &gt; 1.0</span>
        <span class="n">nocc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Check if HOMO&amp;LUMO well defined</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">nocc</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Warning: HOMO&amp;LUMO are not defined properly!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mask of HOMO and LUMO</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nocc</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span>
                    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nocc</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>
            <span class="n">homo_lumo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">homo_lumo</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">homo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Highest occupied energy level in unit hartree&quot;&quot;&quot;</span>
        <span class="c1"># Locate HOMO index, spin-unpolarized case with threshold &gt; 1.0</span>
        <span class="n">i_homo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Check if any system is not occupied at all</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i_homo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;HOMO is not defined properly!&quot;</span><span class="p">)</span>
        <span class="n">homo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">i_homo</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">i_homo</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">homo</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lumo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lowest unoccupied energy level in unit hartree&quot;&quot;&quot;</span>
        <span class="c1"># Locate LUMO index, spin-unpolarized case with threshold &gt; 1.0</span>
        <span class="n">i_lumo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Check if any system is fully occupied</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i_lumo</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;System is fully occupied. LUMO is not defined properly!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Number of real states in batch</span>
            <span class="n">n_real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="o">.</span><span class="n">on_atoms</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Check if the last real state is occupied</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">n_real</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;System is fully occupied. LUMO is not defined properly!&#39;</span><span class="p">)</span>

        <span class="n">lumo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">i_lumo</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">i_lumo</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lumo</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dos_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">energy_units</span><span class="p">[</span><span class="s1">&#39;ev&#39;</span><span class="p">],</span> <span class="n">grid</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Energy distribution of (p)DOS in unit hartree&quot;&quot;&quot;</span>
        <span class="n">e_min</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">ext</span>
        <span class="n">e_max</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="n">ext</span>
        <span class="n">dos_energy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">occupancy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">e_min</span><span class="p">,</span> <span class="n">e_max</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">dos_energy</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Electronic density of states&quot;&quot;&quot;</span>
        <span class="c1"># Mask to remove padding values.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">energy_units</span><span class="p">[</span><span class="s1">&#39;ev&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dos_energy</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">invr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;1/R matrix&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is_periodic</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_invr</span> <span class="o">=</span> <span class="n">build_coulomb_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                                                  <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coulomb_scheme</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">distances</span>
                <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_invr</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invr</span>

    <span class="nd">@invr</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">invr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invr</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Atomic forces&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Forces are computed via the PyTorch auto-grad engine, thus &quot;</span>
                <span class="s2">&quot;the positions tensor must be differentiable, i.e. &quot;</span>
                <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">Geometry.positions.requires_grad = True</span><span class="se">\&quot;</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">gradient</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mermin_energy</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">gradient</span>

<div class="viewcode-block" id="Dftb2.forward">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.Dftb2.html#tbmalt.physics.dftb.Dftb2.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span>
                <span class="n">cache</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the SCC-DFTB calculation.</span>

<span class="sd">        Invoking this will trigger the execution of the self-consistent-charge</span>
<span class="sd">        density functional tight binding theory calculation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            geometry: System(s) upon which the calculation is to be run.</span>
<span class="sd">            orbs: Orbital information associated with said system(s).</span>
<span class="sd">            cache: This stores any information which can be used to bootstrap</span>
<span class="sd">                the calculation. Currently supported values are:</span>

<span class="sd">                    - &quot;q_initial&quot;: initial starting guess for the SCC cycle.</span>

<span class="sd">        Returns:</span>
<span class="sd">            energy: Total energy of the target system(s). If repulsive</span>
<span class="sd">                interactions are not considered, i.e. the repulsion feed is</span>
<span class="sd">                omitted, then this will be the band structure energy. If</span>
<span class="sd">                finite temperature is active then this will be the Mermin</span>
<span class="sd">                free energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1: Initial Setup</span>
        <span class="c1"># Reset the calculator and assign the `geometry` &amp; `orbs` attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orbs</span> <span class="o">=</span> <span class="n">orbs</span>

        <span class="c1"># Gather keyword arguments relevant to the SCC cycle</span>
        <span class="n">kwargs_in</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;filling_temp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_temp</span><span class="p">,</span>
            <span class="s2">&quot;filling_scheme&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filling_scheme</span><span class="p">,</span>
            <span class="s2">&quot;max_scc_iter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_scc_iter</span><span class="p">,</span>
            <span class="s2">&quot;mixer&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixer</span><span class="p">,</span>
            <span class="s2">&quot;suppress_scc_error&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_scc_error</span><span class="p">,</span>
            <span class="s2">&quot;eigen_solver_settings&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solver_settings</span><span class="p">}</span>

        <span class="c1"># If insert any supplied cache data into the keyword argument</span>
        <span class="c1"># dictionary. Currently, the SCC cycle only makes use of the</span>
        <span class="c1"># &quot;q_initial&quot; value. This can be used to specify the initial</span>
        <span class="c1"># charge guess used at the start of the SCC cycle.</span>
        <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs_in</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>

        <span class="c1"># Core Hamiltonian, overlap, and gamma matrices</span>
        <span class="n">hsg_args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_hamiltonian</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>

        <span class="c1"># Step 2: SCC Cycle</span>
        <span class="c1"># The following block performs the actual SCC cycle. However, different</span>
        <span class="c1"># approaches are needed depending on what gradient mode is to be used.</span>
        <span class="c1"># The &quot;direct&quot; approach carries out the SCC cycle without any special</span>
        <span class="c1"># handling. Therefor the gradient will pass through the full SCC cycle.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_mode</span> <span class="o">==</span> <span class="s2">&quot;direct&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">q_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_vectors</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">converged</span><span class="p">)</span> <span class="o">=</span> <span class="n">Dftb2</span><span class="o">.</span><span class="n">scc_cycle</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span> <span class="o">*</span><span class="n">hsg_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_in</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_mode</span> <span class="o">==</span> <span class="s2">&quot;last_step&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_mode</span> <span class="o">==</span> <span class="s2">&quot;implicit&quot;</span><span class="p">:</span>

            <span class="c1"># In the &quot;last step&quot; approach the SCC cycle is performed outside the</span>
            <span class="c1"># purview of the graph and is used only to obtain the converged</span>
            <span class="c1"># charges. Following this, an additional &quot;SCC step&quot; is performed within</span>
            <span class="c1"># the PyTorch graph. The emulates what would happen if one were to</span>
            <span class="c1"># perform the SCC cycle using a highly accurate initial guess for the</span>
            <span class="c1"># charges. The &quot;implicit&quot; approach adds a correction factor to the</span>
            <span class="c1"># gradient.</span>

            <span class="c1"># The arguments to be supplied to the `scc_step` function are</span>
            <span class="c1"># first aggregated here into `step_args`. This is not done only for</span>
            <span class="c1"># the sake of brevity, but to ensure the first call made to these</span>
            <span class="c1"># properties is not done so from within a `torch.no_grad` context.</span>
            <span class="c1"># If this is not done then the cached properties will not be</span>
            <span class="c1"># compatible with the auto-grad graph.</span>
            <span class="n">step_args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_zero_res</span><span class="p">,</span> <span class="o">*</span><span class="n">hsg_args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">q_converged</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="n">Dftb2</span><span class="o">.</span><span class="n">scc_cycle</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">q_zero_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span> <span class="o">*</span><span class="n">hsg_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_in</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_mode</span> <span class="o">==</span> <span class="s2">&quot;implicit&quot;</span><span class="p">:</span>
                <span class="c1"># The implicit method requires the parameter-to-charge gradient</span>
                <span class="c1"># path. Thus, an initial single SCC step must be performed to</span>
                <span class="c1"># &quot;re-attach&quot; the charges. Note that this is in addition to the</span>
                <span class="c1"># final re-attachment call made later on which connects the</span>
                <span class="c1"># other side of the path, i.e. charge-to-properties.</span>
                <span class="n">q_converged</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">Dftb2</span><span class="o">.</span><span class="n">scc_step</span><span class="p">(</span><span class="n">q_converged</span><span class="p">,</span> <span class="o">*</span><span class="n">step_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_in</span><span class="p">)</span>

                <span class="c1"># Construct a second isolated graph which can be used to</span>
                <span class="c1"># compute dF/dq.</span>
                <span class="n">q0</span> <span class="o">=</span> <span class="n">q_converged</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>
                <span class="n">f0</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">Dftb2</span><span class="o">.</span><span class="n">scc_step</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="o">*</span><span class="n">step_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_in</span><span class="p">)</span>

                <span class="c1"># Create and register the gradient callback hook. This will</span>
                <span class="c1"># compute and apply the gradient correction during the</span>
                <span class="c1"># backwards pass. This will use the same mixer as the SCC</span>
                <span class="c1"># cycle unless the user provides a dedicated mixer.</span>
                <span class="n">implicit_mixer</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mixer</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">implicit_mixer</span> <span class="ow">is</span> <span class="kc">None</span>
                                  <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">implicit_mixer</span><span class="p">)</span>
                <span class="n">q_converged</span><span class="o">.</span><span class="n">register_hook</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_implicit_solver_hook</span><span class="p">(</span>
                    <span class="n">f0</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">implicit_mixer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_scc_iter</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">suppress_scc_error</span><span class="p">))</span>

            <span class="c1"># Perform a single SCC step to reconnect q_converged to the graph</span>
            <span class="c1"># so that the auto-grad can pass through the SCC operation.</span>
            <span class="p">(</span><span class="n">q_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_vectors</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span> <span class="o">=</span> <span class="n">Dftb2</span><span class="o">.</span><span class="n">scc_step</span><span class="p">(</span><span class="n">q_converged</span><span class="p">,</span> <span class="o">*</span><span class="n">step_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_in</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grad_mode</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2"> does not correspond to a known gradient mode.&quot;</span>
                <span class="s2">&quot; Valid options are </span><span class="se">\&quot;</span><span class="s2">direct</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">last_step</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">implicit</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate and return the total system energy, taking into account</span>
        <span class="c1"># the entropy term as and when necessary.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mermin_energy</span></div>



    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_implicit_solver_hook</span><span class="p">(</span>
            <span class="n">outputs</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">mixer</span><span class="p">:</span> <span class="n">Mixer</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">suppress_scc_error</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Autograd hook that applies implicit-function gradient correction.</span>

<span class="sd">        The returned callable is meant to be registered on the converged</span>
<span class="sd">        charge tensor via ``Tensor.register_hook``. During the backward</span>
<span class="sd">        pass the hook</span>

<span class="sd">            1. uses `torch.autograd.grad(outputs, inputs, v)` to obtain the</span>
<span class="sd">               vectorJacobian product :math:`J^{T}\cdot v`,</span>
<span class="sd">            2. iteratively solves the linear system</span>
<span class="sd">               :math:`(I  J^{T}) g = \text{incoming_grad}` with the supplied</span>
<span class="sd">               ``mixer``,</span>
<span class="sd">            3. returns the converged `g`, thereby replacing the naive</span>
<span class="sd">               gradient with the fully corrected one.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            outputs: Tensor representing a single SCC step evaluated at the</span>
<span class="sd">                converged charges; provides the *outputs* side of the vector-</span>
<span class="sd">                Jacobian product (VJP) `torch.autograd.grad` call.</span>
<span class="sd">            inputs: Leaf tensor holding the converged charges; supplies the</span>
<span class="sd">                *inputs* side of the VJP.</span>
<span class="sd">            mixer: `Mixer` instance used as the fixed-point accelerator for</span>
<span class="sd">                the implicit solver. It will be reset each time the hook is</span>
<span class="sd">                invoked.</span>
<span class="sd">            max_iter: Maximum number of iterations allowed for the implicit</span>
<span class="sd">                solver before convergence is deemed to have failed.</span>
<span class="sd">            suppress_scc_error: If `True`, the hook will silently return the</span>
<span class="sd">                last iterate when the iteration budget is exhausted; otherwise</span>
<span class="sd">                a `ConvergenceError` is raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            autograd_hook: A callable `hook(grad) -&gt; Tensor` suitable for</span>
<span class="sd">                registration with `Tensor.register_hook`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ConvergenceError: If the implicit solver fails to converge within</span>
<span class="sd">                ``max_iter`` steps and ``suppress_scc_error`` is `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_batch</span> <span class="o">=</span> <span class="n">outputs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">2</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">autograd_hook</span><span class="p">(</span><span class="n">grad</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
            <span class="c1"># Reset the mixer &amp; ensure batch-mode is set appropriately</span>
            <span class="n">mixer</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="n">mixer</span><span class="o">.</span><span class="n">is_batch</span> <span class="o">=</span> <span class="n">is_batch</span>

            <span class="c1"># The variable `grad_current` is used to stor the starting point</span>
            <span class="c1"># for the iterative solver and the mixed result at the end of each</span>
            <span class="c1"># step of an unconverged system.</span>
            <span class="n">grad_current</span> <span class="o">=</span> <span class="n">grad</span>

            <span class="c1"># Loop the self-consistent gradient solver until convergence is</span>
            <span class="c1"># achieved or the iteration limit is reached.</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

                <span class="c1"># Compute the new updated gradient</span>
                <span class="n">grad_new</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">grad_current</span><span class="p">,</span>
                                               <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">grad</span>

                <span class="c1"># Check which systems have converged</span>
                <span class="n">converged</span> <span class="o">=</span> <span class="n">grad_new</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">grad_current</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">le</span><span class="p">(</span>
                    <span class="n">mixer</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">grad_new</span><span class="o">.</span><span class="n">dim_order</span><span class="p">()[</span><span class="mi">1</span><span class="p">:])</span>

                <span class="c1"># If the gradients for all systems have been converged then</span>
                <span class="c1"># return the new corrected gradients.</span>
                <span class="k">if</span> <span class="n">converged</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="c1"># Unlike the SCC cycle function, this does not sequentially</span>
                    <span class="c1"># cull individual systems within as batch as they converge.</span>
                    <span class="c1"># The cost of no doing this should be competitively low</span>
                    <span class="c1"># with minimal adverse effects.</span>
                    <span class="k">return</span> <span class="n">grad_new</span>

                <span class="c1"># If convergence has not yet been achieved, then mix &amp; continue</span>
                <span class="n">grad_current</span> <span class="o">=</span> <span class="n">mixer</span><span class="p">(</span><span class="n">grad_new</span><span class="p">,</span> <span class="n">grad_current</span><span class="p">)</span>

            <span class="c1"># If the iteration limit has been reached, an exception should be</span>
            <span class="c1"># raised, unless otherwise instructed.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_scc_error</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ConvergenceError</span><span class="p">(</span>
                        <span class="s2">&quot;Implicit solver did not converge; &quot;</span>
                        <span class="s2">&quot;iteration limit reached.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">autograd_hook</span>

<div class="viewcode-block" id="Dftb2.reset">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.Dftb2.html#tbmalt.physics.dftb.Dftb2.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset all attributes and cached properties.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_overlap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_core_hamiltonian</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hamiltonian</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_vectors</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Dftb2.scc_step">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.Dftb2.html#tbmalt.physics.dftb.Dftb2.scc_step">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scc_step</span><span class="p">(</span>
            <span class="n">q_in</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">q_zero</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">core_hamiltonian</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
            <span class="n">overlap</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span>
            <span class="n">n_electrons</span><span class="p">:</span> <span class="n">float_like</span><span class="p">,</span> <span class="n">filling_temp</span><span class="p">:</span> <span class="n">float_like</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="n">filling_scheme</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Scheme</span><span class="p">]</span> <span class="o">=</span> <span class="n">fermi_smearing</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a single self-consistent charge cycle step.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            q_in: the input charges. This is normally the charge values from the</span>
<span class="sd">                previous iteration, or from an initial guess if this is the</span>
<span class="sd">                first step. Care must be taken to use either shell or atom</span>
<span class="sd">                resolved charges where appropriate.</span>
<span class="sd">            q_zero: the neutral reference charges. Again care must be taken to</span>
<span class="sd">                ensure that these are provided with the correct resolution,</span>
<span class="sd">                i.e. atom vs shell resolved.</span>
<span class="sd">            core_hamiltonian: the core, non-scc, hamiltonian matrix.</span>
<span class="sd">            overlap: overlap matrix.</span>
<span class="sd">            gamma: gamma matrix.</span>
<span class="sd">            orbs: `OrbitalInfo` object for the associated systems.</span>
<span class="sd">            n_electrons: total number of electrons.</span>
<span class="sd">            filling_temp: electronic temperature used to calculate Fermi-energy.</span>
<span class="sd">                [DEFAULT=0.0]</span>
<span class="sd">            filling_scheme: scheme used for finite temperature broadening.</span>
<span class="sd">                There are two broadening methods, Fermi-Dirac broadening and</span>
<span class="sd">                Gaussian broadening, supported in TBMaLT.</span>
<span class="sd">                [DEFAULT=`fermi_smearing`]</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            eigen_solver_settings: a dictionary storing advanced settings to</span>
<span class="sd">                be provided to the eigen solver.</span>

<span class="sd">        Returns:</span>
<span class="sd">            q_out: the resulting output charges.</span>
<span class="sd">            hamiltonian: the second order hamiltonian matrix. When ``q_in`` is</span>
<span class="sd">                equal to ``q_out`` this will be the &quot;true&quot; self-consistent</span>
<span class="sd">                charge hamiltonian matrix.</span>
<span class="sd">            eig_values: corresponding eigenvalues.</span>
<span class="sd">            eig_vectors: associated eigenvectors.</span>
<span class="sd">            rho: density matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct the shift matrix</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s1">&#39;...i,...ij-&gt;...j&#39;</span><span class="p">,</span> <span class="n">q_in</span> <span class="o">-</span> <span class="n">q_zero</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>

        <span class="n">shifts</span> <span class="o">=</span> <span class="n">prepeat_interleave</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">orbs_per_res</span><span class="p">)</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="p">(</span><span class="n">shifts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">shifts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Compute the second order Hamiltonian matrix</span>
        <span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">core_hamiltonian</span> <span class="o">+</span> <span class="mf">.5</span> <span class="o">*</span> <span class="n">overlap</span> <span class="o">*</span> <span class="n">shifts</span>

        <span class="c1"># Obtain the eigen-values/vectors via an eigen decomposition</span>
        <span class="n">eigen_solver_settings</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;eigen_solver_settings&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">eig_values</span><span class="p">,</span> <span class="n">eig_vectors</span> <span class="o">=</span> <span class="n">eighb</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="o">**</span><span class="n">eigen_solver_settings</span><span class="p">)</span>

        <span class="c1"># Calculate Occupancies</span>
        <span class="c1"># ---------------------</span>
        <span class="c1"># Note that this scale factor assumes spin-restricted and will need to</span>
        <span class="c1"># be refactored when implementing spin-unrestricted calculations.</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">2.0</span>

        <span class="n">e_mask</span> <span class="o">=</span> <span class="n">orbs</span> <span class="k">if</span> <span class="n">orbs</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Compute the new occupancy values, performing smearing as necessary.</span>
        <span class="k">if</span> <span class="n">filling_scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filling_temp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fermi_energy</span> <span class="o">=</span> <span class="n">fermi_search</span><span class="p">(</span><span class="n">eig_values</span><span class="p">,</span> <span class="n">n_electrons</span><span class="p">,</span> <span class="n">filling_temp</span><span class="p">,</span>
                                        <span class="n">filling_scheme</span><span class="p">,</span> <span class="n">e_mask</span><span class="o">=</span><span class="n">e_mask</span><span class="p">)</span>

            <span class="n">occupancy</span> <span class="o">=</span> <span class="n">filling_scheme</span><span class="p">(</span><span class="n">eig_values</span><span class="p">,</span> <span class="n">fermi_energy</span><span class="p">,</span> <span class="n">filling_temp</span><span class="p">,</span>
                                       <span class="n">e_mask</span><span class="o">=</span><span class="n">e_mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale_factor</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">occupancy</span> <span class="o">=</span> <span class="n">aufbau_filling</span><span class="p">(</span><span class="n">eig_values</span><span class="p">,</span> <span class="n">n_electrons</span><span class="p">,</span>
                                       <span class="n">e_mask</span><span class="o">=</span><span class="n">e_mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale_factor</span>

        <span class="c1"># The density matrix is constructed via a two-step approach, similar to</span>
        <span class="c1"># that used in DFTB+. This is done to avoid gradient instabilities that</span>
        <span class="c1"># arise as a result of taking the square root of zeros within the eigen</span>
        <span class="c1"># vector scaling step. While an occupancy value of zero is valid, the</span>
        <span class="c1"># derivative of square root is not. Thus, padding must be applied to these</span>
        <span class="c1"># values during evaluation, and compensated for later on.</span>

        <span class="c1"># Somewhat arbitrary offset needed to ensure occupancies are non-zero</span>
        <span class="n">smallest_occupancy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">occupancy</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">smallest_occupancy</span> <span class="o">-</span> <span class="mf">0.1</span>

        <span class="c1"># Scaled occupancy values (including offset)</span>
        <span class="n">s_occs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s1">&#39;...i,...ji-&gt;...ji&#39;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">occupancy</span> <span class="o">-</span> <span class="n">offset</span><span class="p">),</span> <span class="n">eig_vectors</span><span class="p">)</span>

        <span class="c1"># First the density matrix without occupancy scaling is computed. This is</span>
        <span class="c1"># then added to the scaled density matrix, which includes the offset.</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">eig_vectors</span> <span class="o">@</span> <span class="n">eig_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">s_occs</span> <span class="o">@</span> <span class="n">s_occs</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">*</span> <span class="n">rho</span>

        <span class="c1"># Compute the new charges</span>
        <span class="n">q_out</span> <span class="o">=</span> <span class="n">mulliken</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">orbs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">q_out</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">eig_values</span><span class="p">,</span> <span class="n">eig_vectors</span><span class="p">,</span> <span class="n">rho</span></div>


<div class="viewcode-block" id="Dftb2.scc_cycle">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.physics.dftb.Dftb2.html#tbmalt.physics.dftb.Dftb2.scc_cycle">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scc_cycle</span><span class="p">(</span>
            <span class="n">q_zero</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span> <span class="n">core_hamiltonian</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
            <span class="n">overlap</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">filling_temp</span><span class="p">:</span> <span class="n">float_like</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="n">filling_scheme</span><span class="p">:</span> <span class="n">Scheme</span> <span class="o">=</span> <span class="n">fermi_smearing</span><span class="p">,</span> <span class="n">max_scc_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
            <span class="n">mixer</span><span class="p">:</span> <span class="n">Mixer</span> <span class="o">=</span> <span class="n">Anderson</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the self-consistent charge cycle.</span>

<span class="sd">        This method runs the full self-consistent charge cycle to compute the</span>
<span class="sd">        converged charge(s). This will also return the second order hamiltonian</span>
<span class="sd">        matrix along with other associated data.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            q_zero: the neutral reference charges. Care must be taken to use</span>
<span class="sd">                either shell or atom resolved charges where appropriate.</span>
<span class="sd">            orbs: `OrbitalInfo` object for the associated systems.</span>
<span class="sd">            core_hamiltonian: the core, non-scc, hamiltonian matrix.</span>
<span class="sd">            overlap: overlap matrix.</span>
<span class="sd">            gamma: gamma matrix.</span>
<span class="sd">            filling_temp: electronic temperature used to calculate Fermi-energy.</span>
<span class="sd">                [DEFAULT=0.0]</span>
<span class="sd">            filling_scheme: scheme used for finite temperature broadening.</span>
<span class="sd">                There are two broadening methods, Fermi-Dirac broadening and</span>
<span class="sd">                Gaussian broadening, supported in TBMaLT.</span>
<span class="sd">                [DEFAULT=`fermi_smearing`]</span>
<span class="sd">            max_scc_iter: maximum permitted number of SCC iterations. If one or</span>
<span class="sd">                more system fail to converge within ``max_scc_iter`` cycles</span>
<span class="sd">                then a convergence error will be raised; unless the</span>
<span class="sd">                ``suppress_scc_error`` flag has been set. [DEFAULT=200]</span>
<span class="sd">            mixer: the `Mixer` instance with which to mix the charges during</span>
<span class="sd">                the SCC cycle. [DEFAULT=`Anderson`]</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            suppress_scc_error: if True, convergence errors will be suppressed</span>
<span class="sd">                and the calculation will proceed with as normal. This is of use</span>
<span class="sd">                during fitting when operating on large batches. This way if</span>
<span class="sd">                most systems converge but one does not, then it can just be</span>
<span class="sd">                ignored rather than ending the program. [DEFAULT=False]</span>
<span class="sd">            eigen_solver_settings: a dictionary storing advanced settings to</span>
<span class="sd">                be provided to the eigen solver.</span>

<span class="sd">        Returns:</span>
<span class="sd">            q_converged: the converged charges.</span>
<span class="sd">            hamiltonian: the second order self-consistent charge hamiltonian</span>
<span class="sd">                matrix.</span>
<span class="sd">            eig_values: resulting eigenvalues.</span>
<span class="sd">            eig_vectors: associated eigenvectors.</span>
<span class="sd">            rho: density matrix.</span>
<span class="sd">            system_converged: Tensor of booleans indicating which systems have</span>
<span class="sd">                converged. This is of use when SCF convergence failure</span>
<span class="sd">                exceptions are suppressed via ``suppress_scc_error``.</span>


<span class="sd">        Raises:</span>
<span class="sd">            ConvergenceFailure: if the charge convergence is not reached within</span>
<span class="sd">                the permitted number of iterations as specified by the argument</span>
<span class="sd">                ``max_scc_iter``. The ``suppress_scc_error`` flag can be used to</span>
<span class="sd">                suppress this error.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">was_non_batch</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># Implementation of a batch agnostic self-consistent charge function is</span>
        <span class="c1"># somewhat challenging. While one could create a pair of functions, one</span>
        <span class="c1"># for the batch case and another for the non-batch case this would</span>
        <span class="c1"># require maintaining two almost identical functions. Instead, single</span>
        <span class="c1"># system cases are converted to a batch of size one.</span>
        <span class="k">if</span> <span class="n">was_non_batch</span><span class="p">:</span>
            <span class="n">orbs</span> <span class="o">=</span> <span class="n">OrbitalInfo</span><span class="p">(</span>
                <span class="n">orbs</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">,</span>
                <span class="n">shell_resolved</span><span class="o">=</span><span class="n">orbs</span><span class="o">.</span><span class="n">shell_resolved</span><span class="p">)</span>

            <span class="n">q_zero</span> <span class="o">=</span> <span class="n">q_zero</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">core_hamiltonian</span> <span class="o">=</span> <span class="n">core_hamiltonian</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">system_converged</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">overlap</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="c1"># Reset the mixer and ensure it is in batch-mode</span>
        <span class="n">mixer</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="n">mixer</span><span class="o">.</span><span class="n">is_batch</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Pull out ancillary settings from the keyword arguments</span>
        <span class="n">suppress_scc_error</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;suppress_scc_error&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">eigen_solver_settings</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;eigen_solver_settings&#39;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="c1"># Check if an initial guess has been provided for the charges. If not</span>
        <span class="c1"># then default to q-zero. This is also use to store the mixed charges</span>
        <span class="c1"># at the end of each step for the unconverged systems.</span>
        <span class="n">q_current</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;q_initial&quot;</span><span class="p">,</span> <span class="n">q_zero</span><span class="p">)</span>

        <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">q_zero</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Tensors in which the final results are to be stored. Results are</span>
        <span class="c1"># appended to results tensors as each system converges.</span>
        <span class="n">hamiltonian_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">core_hamiltonian</span><span class="p">)</span>
        <span class="n">rho_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">core_hamiltonian</span><span class="p">)</span>
        <span class="n">q_new_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q_zero</span><span class="p">)</span>
        <span class="n">eig_values_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">core_hamiltonian</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">eig_vectors_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">core_hamiltonian</span><span class="p">)</span>

        <span class="c1"># Tensor to track currently which systems have not yet converged.</span>
        <span class="n">system_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n_electrons</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">q_zero</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Enter the self-consistent charge cycle. This will continue looping until</span>
        <span class="c1"># either the maximum permitted number of iterations has been reached or</span>
        <span class="c1"># convergence has been archived.</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_scc_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Perform a single step of the SCC cycle to generate the new charges.</span>
            <span class="c1"># The SCC step function will also return other important properties</span>
            <span class="c1"># that were calculated during the step.</span>
            <span class="n">q_new</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">eig_values</span><span class="p">,</span> <span class="n">eig_vectors</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">Dftb2</span><span class="o">.</span><span class="n">scc_step</span><span class="p">(</span>
                <span class="n">q_current</span><span class="p">,</span> <span class="n">q_zero</span><span class="p">,</span> <span class="n">core_hamiltonian</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span>
                <span class="n">orbs</span><span class="p">,</span> <span class="n">n_electrons</span><span class="p">,</span> <span class="n">filling_temp</span><span class="p">,</span> <span class="n">filling_scheme</span><span class="p">,</span>
                <span class="o">**</span><span class="n">eigen_solver_settings</span><span class="p">)</span>

            <span class="c1"># Check if the deviation between the current and new charges are</span>
            <span class="c1"># within tolerance. Check is done manually here rather than via</span>
            <span class="c1"># `Mixer.converged`. This because i) said attribute will be removed</span>
            <span class="c1"># and ii) the previous approach required mixing to perform the</span>
            <span class="c1"># tolerance check.</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">le</span><span class="p">((</span><span class="n">q_new</span> <span class="o">-</span> <span class="n">q_current</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">(),</span> <span class="n">mixer</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">q_new</span><span class="o">.</span><span class="n">dim_order</span><span class="p">()[</span><span class="mi">1</span><span class="p">:])</span>

            <span class="c1"># Identify which, if any, systems have converged. Copy over data for</span>
            <span class="c1"># the converged systems into the results tensor.</span>
            <span class="k">if</span> <span class="n">converged</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">system_indices</span><span class="p">[</span><span class="n">converged</span><span class="p">]</span>

                <span class="n">system_converged</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">n_orbs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">orbs</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">)</span>
                <span class="n">n_res</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">res_matrix_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Copy over converged values to the output tensors</span>
                <span class="n">hamiltonian_out</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="p">[</span><span class="n">converged</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">rho_out</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">converged</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">q_new_out</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_res</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_new</span><span class="p">[</span><span class="n">converged</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">eig_values_out</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_values</span><span class="p">[</span><span class="n">converged</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">eig_vectors_out</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_vectors</span><span class="p">[</span><span class="n">converged</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

            <span class="c1"># If all systems have converged, then discontinue the scc cycle.</span>
            <span class="k">if</span> <span class="n">converged</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">break</span>

            <span class="c1"># Otherwise just mix the charges ready for the next step and remove</span>
            <span class="c1"># converged systems from the working tensors.</span>
            <span class="k">elif</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="n">max_scc_iter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">converged</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>

                <span class="c1"># Remove converged systems from the working tensors</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">converged</span>

                <span class="n">orbs</span> <span class="o">=</span> <span class="n">orbs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">n_orbs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">orbs</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">)</span>
                <span class="n">n_res</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">res_matrix_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># When the orbital info entity is sliced, it is also</span>
                <span class="c1"># automatically squeezed to remove any unnecessary padding</span>
                <span class="c1"># values. This must be accounted for when culling the arrays.</span>
                <span class="n">q_new</span> <span class="o">=</span> <span class="n">q_new</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_res</span><span class="p">]</span>
                <span class="n">q_zero</span> <span class="o">=</span> <span class="n">q_zero</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_res</span><span class="p">]</span>
                <span class="n">q_current</span> <span class="o">=</span> <span class="n">q_current</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_res</span><span class="p">]</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_res</span><span class="p">,</span> <span class="p">:</span><span class="n">n_res</span><span class="p">]</span>
                <span class="n">core_hamiltonian</span> <span class="o">=</span> <span class="n">core_hamiltonian</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span>
                <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">n_electrons</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">system_indices</span> <span class="o">=</span> <span class="n">system_indices</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

                <span class="c1"># Cull the converged systems from the mixer.</span>
                <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># No history to cull in the first step as not mixing has taken</span>
                    <span class="c1"># place yet.</span>
                    <span class="n">mixer</span><span class="o">.</span><span class="n">cull</span><span class="p">(</span><span class="n">converged</span><span class="p">,</span> <span class="n">new_size</span><span class="o">=</span><span class="p">[</span><span class="n">n_res</span><span class="p">])</span>

                <span class="n">q_current</span> <span class="o">=</span> <span class="n">mixer</span><span class="p">(</span><span class="n">q_new</span><span class="p">,</span> <span class="n">q_current</span><span class="p">)</span>

            <span class="c1"># However, if the iteration limit has been reached, an exception</span>
            <span class="c1"># should be raised instead.</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">suppress_scc_error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConvergenceError</span><span class="p">(</span>
                    <span class="s2">&quot;SCC cycle failed to converge; iteration limit reached&quot;</span><span class="p">)</span>

            <span class="c1"># Unless instructed to ignore the convergence limit. In which case the</span>
            <span class="c1"># current date for the unconverged systems should be copied into the</span>
            <span class="c1"># output tensors.</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">n_orbs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">orbs</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">)</span>
                <span class="n">n_res</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">res_matrix_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">hamiltonian_out</span><span class="p">[</span><span class="n">system_indices</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span> <span class="o">=</span> <span class="n">hamiltonian</span>
                <span class="n">rho_out</span><span class="p">[</span><span class="n">system_indices</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>
                <span class="n">q_new_out</span><span class="p">[</span><span class="n">system_indices</span><span class="p">,</span> <span class="p">:</span><span class="n">n_res</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_new</span>
                <span class="n">eig_values_out</span><span class="p">[</span><span class="n">system_indices</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_values</span>
                <span class="n">eig_vectors_out</span><span class="p">[</span><span class="n">system_indices</span><span class="p">,</span> <span class="p">:</span><span class="n">n_orbs</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_vectors</span>

        <span class="k">if</span> <span class="n">was_non_batch</span><span class="p">:</span>
            <span class="n">q_new_out</span> <span class="o">=</span> <span class="n">q_new_out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">hamiltonian_out</span> <span class="o">=</span> <span class="n">hamiltonian_out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">eig_values_out</span> <span class="o">=</span> <span class="n">eig_values_out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">eig_vectors_out</span> <span class="o">=</span> <span class="n">eig_vectors_out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">rho_out</span> <span class="o">=</span> <span class="n">rho_out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">system_converged</span> <span class="o">=</span> <span class="n">system_converged</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">q_new_out</span><span class="p">,</span> <span class="n">hamiltonian_out</span><span class="p">,</span> <span class="n">eig_values_out</span><span class="p">,</span> <span class="n">eig_vectors_out</span><span class="p">,</span>
                <span class="n">rho_out</span><span class="p">,</span> <span class="n">system_converged</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, TBMaLT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>