

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tbmalt.physics.dftb.feeds &mdash; TBMaLT 0.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=7026087e"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            TBMaLT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">1. Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html">2. Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">3. Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../development.html">4. Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide.html">5. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release_notes.html">6. Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">TBMaLT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../dftb.html">tbmalt.physics.dftb</a></li>
      <li class="breadcrumb-item active">tbmalt.physics.dftb.feeds</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tbmalt.physics.dftb.feeds</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Slater-Koster integral feed objects.</span>

<span class="sd">This contains all Slater-Koster integral feed objects. These objects are</span>
<span class="sd">responsible for generating the Slater-Koster integrals and for constructing</span>
<span class="sd">the associated Hamiltonian and overlap matrices.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">ndarray</span> <span class="k">as</span> <span class="n">Array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations_with_replacement</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Type</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">CubicSpline</span> <span class="k">as</span> <span class="n">ScipyCubicSpline</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.nn</span><span class="w"> </span><span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">ParameterDict</span><span class="p">,</span> <span class="n">ModuleDict</span><span class="p">,</span> <span class="n">Module</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">OrbitalInfo</span><span class="p">,</span> <span class="n">Periodicity</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.structures.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">atomic_pair_distances</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.ml.integralfeeds</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntegralFeed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.io.skf</span><span class="w"> </span><span class="kn">import</span> <span class="n">Skf</span><span class="p">,</span> <span class="n">VCRSkf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.physics.dftb.slaterkoster</span><span class="w"> </span><span class="kn">import</span> <span class="n">sub_block_rot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.data.elements</span><span class="w"> </span><span class="kn">import</span> <span class="n">chemical_symbols</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.ml</span><span class="w"> </span><span class="kn">import</span> <span class="n">Feed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">pack</span><span class="p">,</span> <span class="n">prepeat_interleave</span><span class="p">,</span> <span class="n">bT</span><span class="p">,</span> <span class="n">bT2</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common.maths.interpolation</span><span class="w"> </span><span class="kn">import</span> <span class="n">PolyInterpU</span><span class="p">,</span> <span class="n">BicubInterpSpl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common.maths.interpolation</span><span class="w"> </span><span class="kn">import</span> <span class="n">CubicSpline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">unique</span>

<span class="c1"># Todo:</span>
<span class="c1">#   - Need to determine why this is so slow for periodic systems.</span>

<span class="n">interp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;polynomial&#39;</span><span class="p">:</span> <span class="n">PolyInterpU</span><span class="p">,</span> <span class="s1">&#39;spline&#39;</span><span class="p">:</span> <span class="n">CubicSpline</span><span class="p">,</span>
               <span class="s1">&#39;bicubic&#39;</span><span class="p">:</span> <span class="n">BicubInterpSpl</span><span class="p">}</span>


<div class="viewcode-block" id="ScipySkFeed">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.ScipySkFeed.html#tbmalt.physics.dftb.feeds.ScipySkFeed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ScipySkFeed</span><span class="p">(</span><span class="n">IntegralFeed</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Slater-Koster based Scipy integral feed for testing DFTB calculations.</span>

<span class="sd">    This feed uses Scipy splines &amp; Slater-Koster transformations to construct</span>
<span class="sd">    Hamiltonian and overlap matrices via the traditional DFTB method. It is</span>
<span class="sd">    important to note that, due to the use of Scipy splines, this class and</span>
<span class="sd">    its methods are not backpropagatable. Thus, this feed should not be used</span>
<span class="sd">    for training.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        on_sites: On-site integrals presented as a dictionary keyed by atomic</span>
<span class="sd">            numbers &amp; valued by a tensor specifying all of associated the on-</span>
<span class="sd">            site integrals; i.e. one for each orbital.</span>
<span class="sd">        off_sites: Off-site integrals; dictionary keyed by tuples of the form</span>
<span class="sd">            (z₁, z₂, s₁, s₂), where zᵢ &amp; sᵢ are the atomic &amp; shell numbers of</span>
<span class="sd">            the interactions, &amp; valued by Scipy `CubicSpline` entities. Note</span>
<span class="sd">            that z₁ must be less than or equal to z₂, see the notes section</span>
<span class="sd">            for further information.</span>
<span class="sd">        device: Device on which the feed object and its contents resides.</span>
<span class="sd">        dtype: dtype used by feed object.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The splines contained within the ``off_sites`` argument must return</span>
<span class="sd">        all relevant bond order integrals; e.g. a s-s interaction should only</span>
<span class="sd">        return a single value for the σ interaction whereas a d-d interaction</span>
<span class="sd">        should return three values when interpolated (σ,π &amp; δ).</span>

<span class="sd">        Furthermore it is critical that no duplicate interactions are present.</span>
<span class="sd">        That is to say if there is a (1, 6, 0, 0) (H[s]-C[s]) key present then</span>
<span class="sd">        there must not also be a (6, 1, 0, 0) (H[s]-C[s]) key present as they</span>
<span class="sd">        are the same interaction. To help prevent this the class will raise an</span>
<span class="sd">        error if the second atomic number is greater than the first; e.g. the</span>
<span class="sd">        key (6, 1, 0, 0) will raise an error but (1, 6, 0, 0) will not.</span>

<span class="sd">    Warnings:</span>
<span class="sd">        This integral feed is not backpropagatable as Scipy splines are used</span>
<span class="sd">        to interpolate the Slater-Koster tables. This is primarily indented to</span>
<span class="sd">        be used for testing purposes.</span>

<span class="sd">        `CubicSpline` instances should not attempt to extrapolate, but rather</span>
<span class="sd">        return NaNs, i.e. &#39;extrapolate=False&#39;. When interpolating `ScipySkFeed`</span>
<span class="sd">        instances will identify and set all NaNs to zero.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: Remove this class</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_sites</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
                 <span class="n">off_sites</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">ScipyCubicSpline</span><span class="p">],</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Ensure that the on_sites are torch tensors</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temp</span> <span class="o">:=</span> <span class="nb">list</span><span class="p">(</span><span class="n">on_sites</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">on_sites</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">on_sites</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Validate the off-site keys</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">off_sites</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lowest Z must be given first in off_site keys&#39;</span><span class="p">)</span>

        <span class="c1"># Pass the dtype and device to the ABC, if none are given the default</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span><span class="p">,</span>
                         <span class="n">temp</span><span class="o">.</span><span class="n">device</span> <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">device</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span> <span class="o">=</span> <span class="n">on_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">off_sites</span> <span class="o">=</span> <span class="n">off_sites</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_off_site_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
                         <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks (off-site only).</span>

<span class="sd">        Constructs the off-site atomic blocks using Slater-Koster integral</span>
<span class="sd">        tables.</span>

<span class="sd">        Arguments:</span>
<span class="sd">              atomic_idx_1: Indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">              atomic_idx_2: Indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                  desired interaction block.</span>
<span class="sd">              geometry: The systems to which the atomic indices relate.</span>
<span class="sd">              orbs: Orbital information associated with said systems.</span>

<span class="sd">          Returns:</span>
<span class="sd">              blocks: Requested atomic interaction sub-blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Identify atomic numbers associated with the interaction</span>
        <span class="n">z_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>
        <span class="n">z_2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>

        <span class="c1"># Get the species&#39; shell lists (basically a list of azimuthal numbers)</span>
        <span class="n">shells_1</span><span class="p">,</span> <span class="n">shells_2</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_1</span><span class="p">],</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_2</span><span class="p">]</span>

        <span class="c1"># Inter-atomic distance and distance vector calculator.</span>
        <span class="n">dist_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)]</span>
                    <span class="o">-</span> <span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">)])</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">u_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_vec</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">dist</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Work out the width of each sub-block then use it to get the row and</span>
        <span class="c1"># column index slicers for placing sub-blocks into their atom-blocks.</span>
        <span class="n">rws</span><span class="p">,</span> <span class="n">cws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">rws</span><span class="p">)]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">cws</span><span class="p">)]</span>

        <span class="c1"># Tensor to hold the resulting atomic-blocks.</span>
        <span class="n">blks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">cws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Loop over the 1st species&#39; shells; where i &amp; l_1 are the shell&#39;s index</span>
        <span class="c1"># &amp; azimuthal numbers respectively. Then over the 2nd species&#39; shells,</span>
        <span class="c1"># but ignore sub-blocks in the lower triangle of homo-atomic blocks as</span>
        <span class="c1"># they can be constructed via symmetrisation.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_1</span><span class="p">):</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">i</span> <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">l_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_2</span><span class="p">[</span><span class="n">o</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="n">o</span><span class="p">):</span>
                <span class="c1"># Retrieve/interpolate the integral spline, remove any NaNs</span>
                <span class="c1"># due to extrapolation then convert to a torch tensor.</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">off_sites</span><span class="p">[(</span><span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)](</span><span class="n">dist</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
                <span class="n">inte</span><span class="p">[</span><span class="n">inte</span> <span class="o">!=</span> <span class="n">inte</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">inte</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

                <span class="c1"># Apply the Slater-Koster transformation</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="n">sub_block_rot</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">l_1</span><span class="p">,</span> <span class="n">l_2</span><span class="p">]),</span> <span class="n">u_vec</span><span class="p">,</span> <span class="n">inte</span><span class="p">)</span>

                <span class="c1"># Add the sub-blocks into their associated atom-blocks</span>
                <span class="n">blks</span><span class="p">[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inte</span>

                <span class="c1"># Add symmetrically equivalent sub-blocks (homo-atomic only)</span>
                <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">l_1</span> <span class="o">+</span> <span class="n">l_2</span><span class="p">)</span>
                    <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inte</span> <span class="o">*</span> <span class="n">sign</span>

        <span class="k">return</span> <span class="n">blks</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_pe_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span>
                   <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span>
                   <span class="n">periodic</span><span class="p">:</span> <span class="n">Periodicity</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks (on-site and off-site) with pbc.</span>

<span class="sd">        Constructs the on-site and off-site atomic blocks using Slater-Koster</span>
<span class="sd">        integral tables for periodic systems.</span>

<span class="sd">        Arguments:</span>
<span class="sd">              atomic_idx_1: Indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">              atomic_idx_2: Indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                  desired interaction block.</span>
<span class="sd">              geometry: The systems to which the atomic indices relate.</span>
<span class="sd">              orbs: Orbital information associated with said systems.</span>
<span class="sd">              periodic: Distance matrix and position vectors including periodic</span>
<span class="sd">                  images.</span>

<span class="sd">          Returns:</span>
<span class="sd">              blocks: Requested atomic interaction sub-blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check whether on-site block</span>
        <span class="n">onsite</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;onsite&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Check whether batch</span>
        <span class="n">n_batch</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="p">)</span>
                   <span class="k">if</span> <span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">5</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Identify atomic numbers associated with the interaction</span>
        <span class="n">z_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>
        <span class="n">z_2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>

        <span class="c1"># Get the species&#39; shell lists (basically a list of azimuthal numbers)</span>
        <span class="n">shells_1</span><span class="p">,</span> <span class="n">shells_2</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_1</span><span class="p">],</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_2</span><span class="p">]</span>

        <span class="c1"># Inter-atomic distance and distance vector calculator.</span>
        <span class="k">if</span> <span class="n">n_batch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># -&gt; single</span>
            <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="p">[:,</span> <span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># -&gt; batch</span>
            <span class="c1"># Split the atomic index due to batch</span>
            <span class="n">sys_idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">_idx_1_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">_idx_2_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

            <span class="c1"># Distance vectors are packed for batch</span>
            <span class="n">dist_vec</span><span class="p">,</span> <span class="n">mask_pack</span> <span class="o">=</span> <span class="n">pack</span><span class="p">([</span>
                    <span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="p">[</span>
                        <span class="n">sys_idx</span><span class="p">[</span><span class="n">ibatch</span><span class="p">]][:,</span> <span class="n">_idx_1_split</span><span class="p">[</span><span class="n">ibatch</span><span class="p">],</span> <span class="n">_idx_2_split</span><span class="p">[</span>
                            <span class="n">ibatch</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">ibatch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sys_idx</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span>
                        <span class="n">value</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">return_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Reduce the dimension of batch</span>
            <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">dist_vec</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>

            <span class="c1"># Mask to select items before padding with correct size</span>
            <span class="n">mask_pack</span> <span class="o">=</span> <span class="n">mask_pack</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Number of images</span>
        <span class="n">ncell</span> <span class="o">=</span> <span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Distance matrix</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Mask for zero-distance terms in on-site block</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>

        <span class="c1"># Reduce the dimension of image</span>
        <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">dist_vec</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">u_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_vec</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">dist</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Work out the width of each sub-block then use it to get the row and</span>
        <span class="c1"># column index slicers for placing sub-blocks into their atom-blocks.</span>
        <span class="n">rws</span><span class="p">,</span> <span class="n">cws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">rws</span><span class="p">)]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">cws</span><span class="p">)]</span>

        <span class="c1"># Tensor to hold the resulting atomic-blocks.</span>
        <span class="n">blks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">cws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Loop over the 1st species&#39; shells; where i &amp; l_1 are the shell&#39;s index</span>
        <span class="c1"># &amp; azimuthal numbers respectively. Then over the 2nd species&#39; shells,</span>
        <span class="c1"># but ignore sub-blocks in the lower triangle of homo-atomic blocks as</span>
        <span class="c1"># they can be constructed via symmetrisation.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_1</span><span class="p">):</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">i</span> <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">l_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_2</span><span class="p">[</span><span class="n">o</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="n">o</span><span class="p">):</span>
                <span class="c1"># Retrieve/interpolate the integral spline, remove any NaNs</span>
                <span class="c1"># due to extrapolation then convert to a torch tensor.</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">off_sites</span><span class="p">[(</span><span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)](</span><span class="n">dist</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
                <span class="n">inte</span><span class="p">[</span><span class="n">inte</span> <span class="o">!=</span> <span class="n">inte</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">inte</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

                <span class="c1"># Apply the Slater-Koster transformation</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="n">sub_block_rot</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">l_1</span><span class="p">,</span> <span class="n">l_2</span><span class="p">]),</span> <span class="n">u_vec</span><span class="p">,</span> <span class="n">inte</span><span class="p">)</span>

                <span class="c1"># Reshape the integral for images and sum together</span>
                <span class="k">if</span> <span class="n">n_batch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">_inte</span> <span class="o">=</span> <span class="n">inte</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inte</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                      <span class="n">inte</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_inte</span> <span class="o">=</span> <span class="n">inte</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">sys_idx</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">ncell</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inte</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                      <span class="n">inte</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)[</span><span class="n">mask_pack</span><span class="p">]</span>

                <span class="c1"># Add the sub-blocks into their associated atom-blocks</span>
                <span class="n">blks</span><span class="p">[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_inte</span>

                <span class="c1"># Add symmetrically equivalent sub-blocks (homo-atomic only)</span>
                <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">onsite</span><span class="p">:</span>
                        <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_inte</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">l_1</span> <span class="o">+</span> <span class="n">l_2</span><span class="p">)</span>
                        <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_inte</span> <span class="o">*</span> <span class="n">sign</span>

        <span class="k">return</span> <span class="n">blks</span>

<div class="viewcode-block" id="ScipySkFeed.blocks">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.ScipySkFeed.html#tbmalt.physics.dftb.feeds.ScipySkFeed.blocks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
               <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks using SK-integral tables.</span>

<span class="sd">          Returns the atomic blocks associated with the atoms in ``atomic_idx_1``</span>
<span class="sd">          interacting with those in ``atomic_idx_2`` splines and Slater-Koster</span>
<span class="sd">          transformations. This is the base method used in DFTB calculations.</span>

<span class="sd">          Note that The № of interaction blocks returned will be equal to the</span>
<span class="sd">          length of the two index lists; i.e. *not* one for every combination.</span>

<span class="sd">          Arguments:</span>
<span class="sd">              atomic_idx_1: Indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">              atomic_idx_2: Indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                  desired interaction block.</span>
<span class="sd">              geometry: The systems to which the atomic indices relate.</span>
<span class="sd">              orbs: Orbital information associated with said systems.</span>

<span class="sd">          Returns:</span>
<span class="sd">              blocks: Requested atomic interaction sub-blocks.</span>

<span class="sd">          Warnings:</span>
<span class="sd">              This is not backpropagatable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the atomic numbers of the atoms</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span>
        <span class="n">zs_1</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">)]</span>
        <span class="n">zs_2</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)]</span>

        <span class="c1"># Ensure all interactions are between identical species pairs.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs_1</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Atoms in atomic_idx_1 must be the same species&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs_2</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Atoms in atomic_idx_2 must be the same species&#39;</span><span class="p">)</span>

        <span class="c1"># Atomic numbers of the species in list 1 and 2</span>
        <span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span> <span class="o">=</span> <span class="n">zs_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zs_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># C-N and N-C are the same interaction: choice has been made to have</span>
        <span class="c1"># only one set of splines for each species pair. Thus, the two lists</span>
        <span class="c1"># may need to be swapped.</span>
        <span class="k">if</span> <span class="n">z_1</span> <span class="o">&gt;</span> <span class="n">z_2</span><span class="p">:</span>
            <span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span> <span class="o">=</span> <span class="n">atomic_idx_2</span><span class="p">,</span> <span class="n">atomic_idx_1</span>
            <span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span> <span class="o">=</span> <span class="n">z_2</span><span class="p">,</span> <span class="n">z_1</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Construct the tensor into which results are to be placed</span>
        <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">n_orbs_on_species</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span><span class="p">)))</span>
        <span class="n">blks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">),</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Identify which are on-site blocks and which are off-site</span>
        <span class="n">on_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_blocks</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">)</span>
        <span class="n">mask_shell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">z_1</span><span class="p">)])</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>
        <span class="n">mask_shell</span><span class="p">[:(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">z_1</span><span class="p">)]))</span>
                     <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">on_site</span><span class="p">):</span>  <span class="c1"># Construct the on-site blocks (if any are present)</span>
            <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">z_1</span><span class="p">)][</span><span class="n">mask_shell</span><span class="p">])</span>

            <span class="c1"># Interactions between images need to be considered for on-site</span>
            <span class="c1"># blocks with pbc.</span>
            <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_periodic</span><span class="p">:</span>
                <span class="n">_on_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pe_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">periodicity</span><span class="p">,</span> <span class="n">onsite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">+</span> <span class="n">_on_site</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="o">~</span><span class="n">on_site</span><span class="p">):</span>  <span class="c1"># Then the off-site blocks</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_periodic</span><span class="p">:</span>
                <span class="n">blks</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_off_site_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blks</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pe_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">periodicity</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flip</span><span class="p">:</span>  <span class="c1"># If the atoms were switched, then a transpose is required.</span>
            <span class="n">blks</span> <span class="o">=</span> <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">blks</span></div>


<div class="viewcode-block" id="ScipySkFeed.from_database">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.ScipySkFeed.html#tbmalt.physics.dftb.feeds.ScipySkFeed.from_database">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_database</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">target</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">],</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ScipySkFeed&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Instantiate instance from an HDF5 database of Slater-Koster files.</span>

<span class="sd">        Instantiate a `ScipySkFeed` instance for the specified elements using</span>
<span class="sd">        integral tables contained within a Slater-Koster HDF5 database.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            path: Path to the HDF5 file from which integrals should be taken.</span>
<span class="sd">            species: Integrals will only be loaded for the requested species.</span>
<span class="sd">            target: Specifies which integrals should be loaded options are</span>
<span class="sd">                &quot;hamiltonian&quot; and &quot;overlap&quot;.</span>
<span class="sd">            device: Device on which the feed object and its contents resides.</span>
<span class="sd">            dtype: dtype used by feed object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sk_feed: A `ScipySkFeed` instance with the requested integrals.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This method interpolates off-site integrals with `CubicSpline`</span>
<span class="sd">            instances.</span>

<span class="sd">            This method will not instantiate `ScipySkFeed` instances directly</span>
<span class="sd">            from human-readable skf files, or a directory thereof. Thus, any</span>
<span class="sd">            such files must first be converted into their binary equivalent.</span>
<span class="sd">            This reduces overhead &amp; file format error instabilities. The code</span>
<span class="sd">            block provide below shows how this can be done:</span>

<span class="sd">            &gt;&gt;&gt; from tbmalt.tools.downloaders import download_dftb_parameter_set</span>
<span class="sd">            &gt;&gt;&gt; url = &#39;https://github.com/dftbparams/auorg/releases/download/v1.1.0/auorg-1-1.tar.xz&#39;</span>
<span class="sd">            &gt;&gt;&gt; path = &quot;auorg.h5&quot;</span>
<span class="sd">            &gt;&gt;&gt; download_dftb_parameter_set(url, path)</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt import OrbitalInfo, Geometry</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import ScipySkFeed</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.io.skf import Skf</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.tools.downloaders import download_dftb_parameter_set</span>
<span class="sd">            &gt;&gt;&gt; from ase.build import molecule</span>
<span class="sd">            &gt;&gt;&gt; import torch</span>
<span class="sd">            &gt;&gt;&gt; torch.set_default_dtype(torch.float64)</span>
<span class="sd">            &gt;&gt;&gt; # Download the auorg-1-1 parameter set</span>
<span class="sd">            &gt;&gt;&gt; url = &#39;https://github.com/dftbparams/auorg/releases/download/v1.1.0/auorg-1-1.tar.xz&#39;</span>
<span class="sd">            &gt;&gt;&gt; path = &quot;auorg.h5&quot;</span>
<span class="sd">            &gt;&gt;&gt; download_dftb_parameter_set(url, path)</span>
<span class="sd">            &gt;&gt;&gt; # Preparation of system to calculate</span>
<span class="sd">            &gt;&gt;&gt; geo = Geometry.from_ase_atoms(molecule(&#39;H2&#39;))</span>
<span class="sd">            &gt;&gt;&gt; orbs = OrbitalInfo(geo.atomic_numbers,</span>
<span class="sd">            ...                    shell_dict={1: [0]})</span>
<span class="sd">            &gt;&gt;&gt; # Definition of feeds</span>
<span class="sd">            &gt;&gt;&gt; h_feed = ScipySkFeed.from_database(path, [1], &#39;hamiltonian&#39;)</span>
<span class="sd">            &gt;&gt;&gt; s_feed = ScipySkFeed.from_database(path, [1], &#39;overlap&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # Matrix elements</span>
<span class="sd">            &gt;&gt;&gt; H = h_feed.matrix(geo, orbs)</span>
<span class="sd">            &gt;&gt;&gt; S = s_feed.matrix(geo, orbs)</span>
<span class="sd">            &gt;&gt;&gt; print(H)</span>
<span class="sd">            tensor([[-0.2386, -0.3211],</span>
<span class="sd">                    [-0.3211, -0.2386]])</span>
<span class="sd">            &gt;&gt;&gt; print(S)</span>
<span class="sd">            tensor([[1.0000, 0.6433],</span>
<span class="sd">                    [0.6433, 1.0000]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># As C-H &amp; C-H interactions are the same only one needs to be loaded.</span>
        <span class="c1"># Thus, only off-site interactions where z₁≤z₂ are generated. However,</span>
        <span class="c1"># integrals are split over the two Slater-Koster tables, thus both must</span>
        <span class="c1"># be loaded.</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># Removes leading zeros from the sk data which may cause errors</span>
            <span class="c1"># when fitting the CubicSpline.</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose here to save effort</span>

        <span class="k">if</span> <span class="n">device</span> <span class="ow">and</span> <span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;cuda&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;`ScipySkFeed` instances do not offer CUDA support as they are&quot;</span>
                <span class="s2">&quot; backed by Scipy splines which are cpu only.5&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure a valid target is selected</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">]:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid target selected; &#39;</span>
                       <span class="s1">&#39;options are &quot;hamiltonian&quot; or &quot;overlap&quot;&#39;</span><span class="p">)</span>

        <span class="n">on_sites</span><span class="p">,</span> <span class="n">off_sites</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="c1"># The species list must be sorted to ensure that the lowest atomic</span>
        <span class="c1"># number comes first in the species pair.</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">species</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">skf</span> <span class="o">=</span> <span class="n">Skf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="c1"># Loop over the off-site interactions &amp; construct the splines.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">skf</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">off_sites</span><span class="p">[</span><span class="n">pair</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScipyCubicSpline</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">clip</span><span class="p">(</span><span class="n">skf</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># The X-Y.skf file may not contain all information. Thus some info</span>
            <span class="c1"># must be loaded from its Y-X counterpart.</span>
            <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">skf_2</span> <span class="o">=</span> <span class="n">Skf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">pair</span><span class="p">)),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">skf_2</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">off_sites</span><span class="p">[</span><span class="n">pair</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="n">key</span><span class="p">),)]</span> <span class="o">=</span> <span class="n">ScipyCubicSpline</span><span class="p">(</span>
                            <span class="o">*</span><span class="n">clip</span><span class="p">(</span><span class="n">skf_2</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Construct the onsite interactions</span>
                <span class="c1"># Repeated so there&#39;s 1 value per orbital not just per shell.</span>
                <span class="n">on_sites_vals</span> <span class="o">=</span> <span class="n">skf</span><span class="o">.</span><span class="n">on_sites</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skf</span><span class="o">.</span><span class="n">on_sites</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="s1">&#39;overlap&#39;</span><span class="p">:</span>  <span class="c1"># use an identify matrix for S</span>
                    <span class="n">on_sites_vals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">on_sites_vals</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

                <span class="n">on_sites</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_sites_vals</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">on_sites</span><span class="p">,</span> <span class="n">off_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="n">chemical_symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">elements</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="SkFeed">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkFeed.html#tbmalt.physics.dftb.feeds.SkFeed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SkFeed</span><span class="p">(</span><span class="n">IntegralFeed</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Slater-Koster based integral feed for DFTB calculations.</span>

<span class="sd">    This feed uses polynomial and cubic-spline interpolators in tandem with</span>
<span class="sd">    Slater-Koster transformations to construct Hamiltonian and overlap matrices</span>
<span class="sd">    in line with the traditional DFTB method.</span>

<span class="sd">    Arguments:</span>
<span class="sd">            on_sites: A `SkfOnSiteFeed` (preferred) representing the on-site</span>
<span class="sd">            terms. Any `Feed` instance may be provided so long as its `forward`</span>
<span class="sd">            method accepts an atomic number (e.g. int or str) and returns</span>
<span class="sd">            magnetically resolved on-site energies.</span>
<span class="sd">            Legacy (deprecated): torch `ParameterDict` where keys are atomic</span>
<span class="sd">            numbers as strings and values are torch parameters encoding the</span>
<span class="sd">            on-site energies for each magnetically resolved orbital. Support</span>
<span class="sd">            for `ParameterDict` is retained for backwards compatibility but is</span>
<span class="sd">            discouraged and will be removed in a future release.</span>
<span class="sd">        off_sites: A torch `ModuleDict` containing the off-site integrals</span>
<span class="sd">            required for constructing Hamiltonian and/or overlap matrices.</span>
<span class="sd">            The keys are strings representing tuples in the format</span>
<span class="sd">            `&quot;(z₁, z₂, s₁, s₂)&quot;`, where `z₁` &amp; `z₂` are the atomic numbers</span>
<span class="sd">            of the interacting atoms (with `z₁ ≤ z₂`), and `s₁` &amp; `s₂` are</span>
<span class="sd">            their respective shell numbers. Keys must exactly match the</span>
<span class="sd">            string obtained from converting a tuple to a string, including</span>
<span class="sd">            the parentheses and spaces; for example, `&quot;(1, 6, 0, 0)&quot;`. The</span>
<span class="sd">            values are interpolation modules, such as `CubicSpline`</span>
<span class="sd">            instances, that provide the bond order integrals for the</span>
<span class="sd">            specified interactions.</span>
<span class="sd">        device: Device on which the feed object and its contents resides.</span>
<span class="sd">        dtype: dtype used by feed object.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The splines contained within the ``off_sites`` argument must return</span>
<span class="sd">        all relevant bond order integrals; e.g. an s-s interaction should only</span>
<span class="sd">        return a single value for the σ interaction whereas a d-d interaction</span>
<span class="sd">        should return three values when interpolated (σ, π &amp; δ).</span>

<span class="sd">        Furthermore, it is critical that no duplicate interactions are present.</span>
<span class="sd">        That is to say if there is a (1, 6, 0, 0) (H[s]-C[s]) key present then</span>
<span class="sd">        there must not also be a (6, 1, 0, 0) (H[s]-C[s]) key present as they</span>
<span class="sd">        are the same interaction. To help prevent this the class will raise an</span>
<span class="sd">        error if the second atomic number is greater than the first; e.g. the</span>
<span class="sd">        key (6, 1, 0, 0) will raise an error but (1, 6, 0, 0) will not.</span>

<span class="sd">    Warnings:</span>
<span class="sd">        `CubicSpline` instances should not attempt to extrapolate, but rather</span>
<span class="sd">        return NaNs, i.e. &#39;extrapolate=False&#39;. When interpolating `SkFeed`</span>
<span class="sd">        instances will identify and set all NaNs to zero.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">on_sites</span><span class="p">:</span> <span class="n">SkfOnSiteFeed</span> <span class="o">|</span> <span class="n">Feed</span> <span class="o">|</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span>
            <span class="n">off_sites</span><span class="p">:</span> <span class="n">ModuleDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Module</span><span class="p">],</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on_sites</span><span class="p">,</span> <span class="n">ParameterDict</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Deprecated: `on_sites` as `torch.nn.ParameterDict` is &quot;</span>
                <span class="s2">&quot;retained for backwards compatibility only and is slated for &quot;</span>
                <span class="s2">&quot;removal in a future release. Please use `SkfOnSiteFeed` &quot;</span>
                <span class="s2">&quot;or another `Feed` whose `forward(z)` method returns &quot;</span>
                <span class="s2">&quot;magnetically resolved on-site energies.&quot;</span><span class="p">,</span>
                <span class="ne">PendingDeprecationWarning</span><span class="p">)</span>


        <span class="c1"># Pass the dtype and device to the ABC, if none are given the default</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on_sites</span><span class="p">,</span> <span class="n">ParameterDict</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">on_sites</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">on_sites</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span><span class="p">,</span>
                         <span class="n">temp</span><span class="o">.</span><span class="n">device</span> <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on_sites</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;An instance of `Feed` or `torch.nn.ParameterDict` was &quot;</span>
                <span class="s2">&quot;expected for the attribute `on_sites`, but a standard Python &quot;</span>
                <span class="s2">&quot;`dict` was received.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">off_sites</span><span class="p">,</span> <span class="n">ModuleDict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;An instance of `torch.nn.ModuleDict` was expected for the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;attribute `off_sites`, but a/an `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">off_sites</span><span class="p">)</span><span class="si">}</span><span class="s2">` was &quot;</span>
                <span class="s2">&quot;received.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">off_sites</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__validate_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_on_sites</span><span class="p">:</span> <span class="n">Feed</span> <span class="o">|</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">on_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span> <span class="o">=</span> <span class="n">off_sites</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">on_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameter dictionary of on-site values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_sites</span>

    <span class="nd">@on_sites</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">on_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]):</span>

        <span class="c1"># Ensure that the on-site terms are supplied via a `ParameterDict` and</span>
        <span class="c1"># not a standard Python `dict`. Using a standard `dict` would modify</span>
        <span class="c1"># the behaviour of the feed in unexpected ways.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;An instance of `Feed` or `torch.nn.ParameterDict` was &quot;</span>
                <span class="s2">&quot;expected for the attribute `on_sites`, but a standard Python &quot;</span>
                <span class="s2">&quot;`dict` was received.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_on_sites</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">off_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ModuleDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Module</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Module dictionary of off-site feed modules.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span>

    <span class="nd">@off_sites</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">off_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ModuleDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Module</span><span class="p">]):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ModuleDict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;An instance of `torch.nn.ModuleDict` was expected for the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;attribute `off_sites`, but a/an `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">` was &quot;</span>
                <span class="s2">&quot;received.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__validate_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_off_site_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
                         <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks (off-site only).</span>

<span class="sd">        Constructs the off-site atomic blocks using Slater-Koster integral</span>
<span class="sd">        tables.</span>

<span class="sd">        Arguments:</span>
<span class="sd">              atomic_idx_1: Indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">              atomic_idx_2: Indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                  desired interaction block.</span>
<span class="sd">              geometry: The systems to which the atomic indices relate.</span>
<span class="sd">              orbs: Orbital information associated with said systems.</span>
<span class="sd">          Returns:</span>
<span class="sd">              blocks: Requested atomic interaction sub-blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Identify atomic numbers associated with the interaction</span>
        <span class="n">z_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>
        <span class="n">z_2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>

        <span class="c1"># Get the species&#39; shell lists (basically a list of azimuthal numbers)</span>
        <span class="n">shells_1</span><span class="p">,</span> <span class="n">shells_2</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_1</span><span class="p">],</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_2</span><span class="p">]</span>

        <span class="c1"># Inter-atomic distance and distance vector calculator.</span>
        <span class="n">dist_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)]</span>
                    <span class="o">-</span> <span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">)])</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">u_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_vec</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">dist</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Work out the width of each sub-block then use it to get the row and</span>
        <span class="c1"># column index slicers for placing sub-blocks into their atom-blocks.</span>
        <span class="n">rws</span><span class="p">,</span> <span class="n">cws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">rws</span><span class="p">)]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">cws</span><span class="p">)]</span>

        <span class="c1"># Tensor to hold the resulting atomic-blocks.</span>
        <span class="n">blks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">cws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Loop over the 1st species&#39; shells; where i &amp; l_1 are the shell&#39;s index</span>
        <span class="c1"># &amp; azimuthal numbers respectively. Then over the 2nd species&#39; shells,</span>
        <span class="c1"># but ignore sub-blocks in the lower triangle of homo-atomic blocks as</span>
        <span class="c1"># they can be constructed via symmetrisation.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_1</span><span class="p">):</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">i</span> <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">l_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_2</span><span class="p">[</span><span class="n">o</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="n">o</span><span class="p">):</span>
                <span class="c1"># Retrieve/interpolate the integral spline, remove any NaNs</span>
                <span class="c1"># due to extrapolation then convert to a torch tensor.</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">((</span><span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))](</span><span class="n">dist</span><span class="p">)</span>

                <span class="c1"># Apply the Slater-Koster transformation</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="n">sub_block_rot</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">l_1</span><span class="p">,</span> <span class="n">l_2</span><span class="p">]),</span> <span class="n">u_vec</span><span class="p">,</span> <span class="n">inte</span><span class="p">)</span>

                <span class="c1"># Add the sub-blocks into their associated atom-blocks</span>
                <span class="n">blks</span><span class="p">[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inte</span>

                <span class="c1"># Add symmetrically equivalent sub-blocks (homo-atomic only)</span>
                <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">l_1</span> <span class="o">+</span> <span class="n">l_2</span><span class="p">)</span>
                    <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inte</span> <span class="o">*</span> <span class="n">sign</span>

        <span class="k">return</span> <span class="n">blks</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_pe_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
                   <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span>
                   <span class="n">periodic</span><span class="p">:</span> <span class="n">Periodicity</span><span class="p">,</span> <span class="n">onsite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks (on-site and off-site) with pbc.</span>

<span class="sd">        Constructs the on-site and off-site atomic blocks using Slater-Koster</span>
<span class="sd">        integral tables for periodic systems.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            atomic_idx_1: Indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            atomic_idx_2: Indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            geometry: The systems to which the atomic indices relate.</span>
<span class="sd">            orbs: Orbital information associated with said systems.</span>
<span class="sd">            periodic: Periodic object containing distance matrix and position</span>
<span class="sd">                vectors for periodic images.</span>
<span class="sd">            onsite: Used to signal that the provided blocks represent</span>
<span class="sd">                on-site interactions. [DEFAULT=`False`]</span>

<span class="sd">          Returns:</span>
<span class="sd">              blocks: Requested atomic interaction sub-blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check whether batch</span>
        <span class="n">n_batch</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="p">)</span>
                   <span class="k">if</span> <span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">5</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Identify atomic numbers associated with the interaction</span>
        <span class="n">z_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>
        <span class="n">z_2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>

        <span class="c1"># Get the species&#39; shell lists (basically a list of azimuthal numbers)</span>
        <span class="n">shells_1</span><span class="p">,</span> <span class="n">shells_2</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_1</span><span class="p">],</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_2</span><span class="p">]</span>

        <span class="c1"># Inter-atomic distance and distance vector calculator.</span>
        <span class="k">if</span> <span class="n">n_batch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># -&gt; single</span>
            <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="p">[:,</span> <span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># -&gt; batch</span>
            <span class="c1"># Split the atomic index due to batch</span>
            <span class="n">sys_idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Convert locations at which a split should be made into bucket</span>
            <span class="c1"># size values, as needed by PyTorch.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">_idx_1_split</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">idx</span><span class="p">)</span>
            <span class="n">_idx_2_split</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">idx</span><span class="p">)</span>

            <span class="c1"># Distance vectors are packed for batch</span>
            <span class="n">dist_vec</span><span class="p">,</span> <span class="n">mask_pack</span> <span class="o">=</span> <span class="n">pack</span><span class="p">([</span>
                    <span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="p">[</span>
                        <span class="n">sys_idx</span><span class="p">[</span><span class="n">ibatch</span><span class="p">]][:,</span> <span class="n">_idx_1_split</span><span class="p">[</span><span class="n">ibatch</span><span class="p">],</span> <span class="n">_idx_2_split</span><span class="p">[</span>
                            <span class="n">ibatch</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">ibatch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys_idx</span><span class="p">))],</span>
                        <span class="n">value</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">return_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Reduce the dimension of batch</span>
            <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">dist_vec</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>

            <span class="c1"># Mask to select items before padding with correct size</span>
            <span class="n">mask_pack</span> <span class="o">=</span> <span class="n">mask_pack</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Number of images</span>
        <span class="n">ncell</span> <span class="o">=</span> <span class="n">periodic</span><span class="o">.</span><span class="n">neighbour_vector</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Distance matrix</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Mask for zero-distance terms in on-site block</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>

        <span class="c1"># Reduce the dimension of image</span>
        <span class="n">dist_vec</span> <span class="o">=</span> <span class="n">dist_vec</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">u_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_vec</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">dist</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Work out the width of each sub-block then use it to get the row and</span>
        <span class="c1"># column index slicers for placing sub-blocks into their atom-blocks.</span>
        <span class="n">rws</span><span class="p">,</span> <span class="n">cws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">rws</span><span class="p">)]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">cws</span><span class="p">)]</span>

        <span class="c1"># Tensor to hold the resulting atomic-blocks.</span>
        <span class="n">blks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">cws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Loop over the 1st species&#39; shells; where i &amp; l_1 are the shell&#39;s index</span>
        <span class="c1"># &amp; azimuthal numbers respectively. Then over the 2nd species&#39; shells,</span>
        <span class="c1"># but ignore sub-blocks in the lower triangle of homo-atomic blocks as</span>
        <span class="c1"># they can be constructed via symmetrisation.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_1</span><span class="p">):</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">i</span> <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">l_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_2</span><span class="p">[</span><span class="n">o</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="n">o</span><span class="p">):</span>
                <span class="c1"># Retrieve/interpolate the integral spline, remove any NaNs</span>
                <span class="c1"># due to extrapolation then convert to a torch tensor.</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">((</span><span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))](</span><span class="n">dist</span><span class="p">)</span>
                <span class="n">inte</span><span class="p">[</span><span class="n">inte</span> <span class="o">!=</span> <span class="n">inte</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="c1"># Apply the Slater-Koster transformation</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="n">sub_block_rot</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">l_1</span><span class="p">,</span> <span class="n">l_2</span><span class="p">]),</span> <span class="n">u_vec</span><span class="p">,</span> <span class="n">inte</span><span class="p">)</span>

                <span class="c1"># Reshape the integral for images and sum together</span>
                <span class="k">if</span> <span class="n">n_batch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">_inte</span> <span class="o">=</span> <span class="n">inte</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ncell</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inte</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                      <span class="n">inte</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_inte</span> <span class="o">=</span> <span class="n">inte</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys_idx</span><span class="p">),</span> <span class="n">ncell</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inte</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                                      <span class="n">inte</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)[</span><span class="n">mask_pack</span><span class="p">]</span>

                <span class="c1"># 5, ncell, -1, 1, 1</span>
                <span class="c1"># Add the sub-blocks into their associated atom-blocks</span>
                <span class="n">blks</span><span class="p">[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_inte</span>

                <span class="c1"># Add symmetrically equivalent sub-blocks (homo-atomic only)</span>
                <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">onsite</span><span class="p">:</span>
                        <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_inte</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">l_1</span> <span class="o">+</span> <span class="n">l_2</span><span class="p">)</span>
                        <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_inte</span> <span class="o">*</span> <span class="n">sign</span>

        <span class="k">return</span> <span class="n">blks</span>

<div class="viewcode-block" id="SkFeed.blocks">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkFeed.html#tbmalt.physics.dftb.feeds.SkFeed.blocks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
               <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks using SK-integral tables.</span>

<span class="sd">        Returns the atomic blocks associated with the atoms in ``atomic_idx_1``</span>
<span class="sd">        interacting with those in ``atomic_idx_2`` splines and Slater-Koster</span>
<span class="sd">        transformations. This is the base method used in DFTB calculations.</span>
<span class="sd">        Note that The № of interaction blocks returned will be equal to the</span>
<span class="sd">        length of the two index lists; i.e. *not* one for every combination.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            atomic_idx_1: Indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            atomic_idx_2: Indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            geometry: The systems to which the atomic indices relate.</span>
<span class="sd">            orbs: Orbital information associated with said systems.</span>

<span class="sd">        Returns:</span>
<span class="sd">            blocks: Requested atomic interaction sub-blocks.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the atomic numbers of the atoms</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span>
        <span class="n">zs_1</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">)]</span>
        <span class="n">zs_2</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)]</span>

        <span class="c1"># Ensure all interactions are between identical species pairs.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs_1</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Atoms in atomic_idx_1 must be the same species&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs_2</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Atoms in atomic_idx_2 must be the same species&#39;</span><span class="p">)</span>

        <span class="c1"># Atomic numbers of the species in list 1 and 2</span>
        <span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span> <span class="o">=</span> <span class="n">zs_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zs_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># C-N and N-C are the same interaction: choice has been made to have</span>
        <span class="c1"># only one set of splines for each species pair. Thus, the two lists</span>
        <span class="c1"># may need to be swapped.</span>
        <span class="k">if</span> <span class="n">z_1</span> <span class="o">&gt;</span> <span class="n">z_2</span><span class="p">:</span>
            <span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span> <span class="o">=</span> <span class="n">atomic_idx_2</span><span class="p">,</span> <span class="n">atomic_idx_1</span>
            <span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span> <span class="o">=</span> <span class="n">z_2</span><span class="p">,</span> <span class="n">z_1</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Construct the tensor into which results are to be placed</span>
        <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">n_orbs_on_species</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span><span class="p">)))</span>
        <span class="n">blks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">),</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Identify which are on-site blocks and which are off-site</span>
        <span class="n">on_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_blocks</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">)</span>
        <span class="n">mask_shell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_1</span><span class="o">.</span><span class="n">item</span><span class="p">()])),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Construct the on-site blocks (if any are present)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">on_site</span><span class="p">):</span>
            <span class="c1"># Check for legacy on-site type. Previously, on-sites were</span>
            <span class="c1"># provided by way of a `ParameterDict`. This has since been</span>
            <span class="c1"># replaced by a `Feed` object, namely `SkfOnSiteFeed`. Support</span>
            <span class="c1"># for `ParameterDict` style on-sites will be removed in a future</span>
            <span class="c1"># update.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">,</span> <span class="n">ParameterDict</span><span class="p">):</span>
                <span class="n">on_site_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">z_1</span><span class="o">.</span><span class="n">item</span><span class="p">())]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">on_site_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">z_1</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>

            <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">on_site_values</span><span class="p">[</span><span class="n">mask_shell</span><span class="p">])</span>

            <span class="c1"># Interactions between images need to be considered for on-site</span>
            <span class="c1"># blocks with pbc.</span>
            <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_periodic</span><span class="p">:</span>
                <span class="n">_on_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pe_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">periodicity</span><span class="p">,</span> <span class="n">onsite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">+</span> <span class="n">_on_site</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="o">~</span><span class="n">on_site</span><span class="p">):</span>  <span class="c1"># Then the off-site blocks</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_periodic</span><span class="p">:</span>
                <span class="n">blks</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_off_site_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blks</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pe_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">periodicity</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flip</span><span class="p">:</span>  <span class="c1"># If the atoms were switched, then a transpose is required.</span>
            <span class="n">blks</span> <span class="o">=</span> <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">blks</span></div>


<div class="viewcode-block" id="SkFeed.from_database">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkFeed.html#tbmalt.physics.dftb.feeds.SkFeed.from_database">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_database</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">target</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">],</span>
            <span class="n">interpolation</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Feed</span><span class="p">]</span> <span class="o">=</span> <span class="n">PolyInterpU</span><span class="p">,</span>
            <span class="n">requires_grad_onsite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">requires_grad_offsite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SkFeed&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Instantiate instance from an HDF5 database of Slater-Koster files.</span>

<span class="sd">        Instantiate a `SkFeed` instance for the specified elements using</span>
<span class="sd">        integral tables contained within a Slater-Koster HDF5 database.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            path: Path to the HDF5 file from which integrals should be taken.</span>
<span class="sd">            species: Integrals will only be loaded for the requested species.</span>
<span class="sd">            target: Specifies which integrals should be loaded, options are</span>
<span class="sd">                &quot;hamiltonian&quot; and &quot;overlap&quot;.</span>
<span class="sd">            interpolation: The `Feed` derived class that should be used to</span>
<span class="sd">                interpolate the off-site Slater-Koster parameters. This may</span>
<span class="sd">                be `CubicSpline`, `PolyInterpU` or any other `Feed` derived</span>
<span class="sd">                class that can perform univarient interpolation. If this is</span>
<span class="sd">                not manually specified then it will default to `PolyInterpU`</span>
<span class="sd">                which is a PyTorch implimentation of the interpolation method</span>
<span class="sd">                used in DFTB+. [DEFAULT=`PolyInterpU`]</span>
<span class="sd">            requires_grad_onsite: When set to `True` gradient tracking will be</span>
<span class="sd">                enabled for the on-site parameters. This flag is ignored for</span>
<span class="sd">                the overlap matrix case as its on-site terms are always unity.</span>
<span class="sd">                [DEFAULT=`False`]</span>
<span class="sd">            requires_grad_offsite: When set to `True` gradient tracking will</span>
<span class="sd">                be enabled for the off-site parameters. [DEFAULT=`False`]</span>
<span class="sd">            device: Device on which the feed object and its contents resides.</span>
<span class="sd">            dtype: dtype used by feed object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sk_feed: A `SkFeed` instance with the requested integrals.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This method will not instantiate `SkFeed` instances directly</span>
<span class="sd">            from human-readable skf files, or a directory thereof. Thus, any</span>
<span class="sd">            such files must first be converted into their binary equivalent.</span>
<span class="sd">            This reduces overhead &amp; file format error instabilities. The code</span>
<span class="sd">            block provide below shows how this can be done:</span>

<span class="sd">            &gt;&gt;&gt; from tbmalt.io.skf import Skf</span>
<span class="sd">            &gt;&gt;&gt; Zs = [&#39;H&#39;, &#39;C&#39;, &#39;Au&#39;, &#39;S&#39;]</span>
<span class="sd">            &gt;&gt;&gt; for file in [f&#39;{i}-{j}.skf&#39; for i in Zs for j in Zs]:</span>
<span class="sd">            ...     Skf.read(file).write(&#39;my_skf.hdf5&#39;)</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt import OrbitalInfo, Geometry</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import SkFeed</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.tools.downloaders import download_dftb_parameter_set</span>
<span class="sd">            &gt;&gt;&gt; from ase.build import molecule</span>
<span class="sd">            &gt;&gt;&gt; import torch</span>
<span class="sd">            &gt;&gt;&gt; torch.set_default_dtype(torch.float64)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Download auorg-1-1 parameter set</span>
<span class="sd">            &gt;&gt;&gt; url = &#39;https://github.com/dftbparams/auorg/releases/download/v1.1.0/auorg-1-1.tar.xz&#39;</span>
<span class="sd">            &gt;&gt;&gt; path = &quot;auorg.h5&quot;</span>
<span class="sd">            &gt;&gt;&gt; download_dftb_parameter_set(url, path)</span>
<span class="sd">            &gt;&gt;&gt; # Specify target system</span>
<span class="sd">            &gt;&gt;&gt; geo = Geometry.from_ase_atoms(molecule(&#39;H2&#39;))</span>
<span class="sd">            &gt;&gt;&gt; orbs = OrbitalInfo(geo.atomic_numbers, shell_dict={1: [0]})</span>
<span class="sd">            &gt;&gt;&gt; # Define feeds</span>
<span class="sd">            &gt;&gt;&gt; h_feed = SkFeed.from_database(path, [1], &#39;hamiltonian&#39;)</span>
<span class="sd">            &gt;&gt;&gt; s_feed = SkFeed.from_database(path, [1], &#39;overlap&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # Construct Hamiltonian and overlap matrices</span>
<span class="sd">            &gt;&gt;&gt; H = h_feed.matrix(geo, orbs)</span>
<span class="sd">            &gt;&gt;&gt; S = s_feed.matrix(geo, orbs)</span>
<span class="sd">            &gt;&gt;&gt; print(H)</span>
<span class="sd">            tensor([[-0.2386, -0.3211],</span>
<span class="sd">                    [-0.3211, -0.2386]])</span>
<span class="sd">            &gt;&gt;&gt; print(S)</span>
<span class="sd">            tensor([[1.0000, 0.6433],</span>
<span class="sd">                    [0.6433, 1.0000]])</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># As C-H &amp; C-H interactions are the same only one needs to be loaded.</span>
        <span class="c1"># Thus, only off-site interactions where z₁≤z₂ are generated. However,</span>
        <span class="c1"># integrals are split over the two Slater-Koster tables, thus both must</span>
        <span class="c1"># be loaded.</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">construct_interpolator</span><span class="p">(</span>
                <span class="n">grid</span><span class="p">,</span> <span class="n">interaction_value</span><span class="p">,</span> <span class="n">interpolation_type</span><span class="p">,</span>
                <span class="n">grad</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_kwargs</span><span class="p">):</span>
            <span class="c1"># Clip the knot values so that any leading zeros are removed from</span>
            <span class="c1"># the Slater-Koster data. This is done to prevent some issues that</span>
            <span class="c1"># results from fitting splines to the knots with leading zeros.</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">interaction_value</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>
            <span class="n">interaction_value</span> <span class="o">=</span> <span class="n">interaction_value</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Convert the y-knot values to a `torch.nn.Parameter`</span>
            <span class="c1"># enable gradient tracking as required.</span>
            <span class="n">interaction_value</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
                <span class="n">interaction_value</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">grad</span><span class="p">)</span>

            <span class="c1"># Finally construct and return the interpolator</span>
            <span class="k">return</span> <span class="n">interpolation_type</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">interaction_value</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_kwargs</span><span class="p">)</span>

        <span class="c1"># Ensure a valid target is selected</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">]:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid target selected; &#39;</span>
                       <span class="s1">&#39;options are &quot;hamiltonian&quot; or &quot;overlap&quot;&#39;</span><span class="p">)</span>

        <span class="n">off_sites</span> <span class="o">=</span> <span class="n">ModuleDict</span><span class="p">()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span> <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="n">ScipyCubicSpline</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="c1"># The species list must be sorted to ensure that the lowest atomic</span>
        <span class="c1"># number comes first in the species pair.</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">species</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>

            <span class="n">skf</span> <span class="o">=</span> <span class="n">Skf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Loop over the off-site interactions &amp; construct the splines.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">skf</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">off_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">pair</span> <span class="o">+</span> <span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">construct_interpolator</span><span class="p">(</span>
                    <span class="n">skf</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">requires_grad_offsite</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">params</span><span class="p">)</span>

            <span class="c1"># The X-Y.skf file may not contain all information. Thus, some info</span>
            <span class="c1"># must be loaded from its Y-X counterpart.</span>
            <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">skf_2</span> <span class="o">=</span> <span class="n">Skf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">pair</span><span class="p">)),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">skf_2</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pair</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="n">key</span><span class="p">),))</span>
                        <span class="n">off_sites</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">construct_interpolator</span><span class="p">(</span>
                            <span class="n">skf_2</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">requires_grad_offsite</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Construct on-site feed instance</span>
        <span class="n">on_sites</span> <span class="o">=</span> <span class="n">SkfOnSiteFeed</span><span class="o">.</span><span class="n">from_database</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad_onsite</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">on_sites</span><span class="p">,</span> <span class="n">off_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">off_sites</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="sa">r</span><span class="s1">&#39;^(\d+), (\d+), (\d+), (\d+)$&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">groups</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]}</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">chemical_symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">elements</span><span class="p">)])</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">elements</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__validate_key</span><span class="p">(</span><span class="n">key_string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate format of an off-site module-dictionary key.</span>

<span class="sd">        Validates that the provided string matches the expected format of a tuple</span>
<span class="sd">        converted to a string, i.e., &quot;(z₁, z₂, s₁, s₂)&quot;.</span>

<span class="sd">        The string must:</span>
<span class="sd">        - Start with a left parenthesis &#39;(&#39;</span>
<span class="sd">        - End with a right parenthesis &#39;)&#39;</span>
<span class="sd">        - Contain exactly four comma-separated integers</span>
<span class="sd">        - Have exactly one space after each comma</span>
<span class="sd">        - Ensure that z₁ ≤ z₂</span>

<span class="sd">        Arguments:</span>
<span class="sd">            key_string: The string to validate.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If any of the validation checks fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Check if the string starts with &#39;(&#39; and ends with &#39;)&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">key_string</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key_string</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)):</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;The string must start with &#39;(&#39; and end with &#39;)&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remove the parentheses</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">key_string</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Define the expected pattern</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^(\d+), (\d+), (\d+), (\d+)$&#39;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;The string must contain exactly four comma-separated integers, &quot;</span>
                    <span class="s2">&quot;with exactly one space after each comma.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>

                <span class="c1"># Check if z₁ ≤ z₂</span>
                <span class="k">if</span> <span class="n">z1</span> <span class="o">&gt;</span> <span class="n">z2</span><span class="p">:</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;The first atomic number z₁ must be less than or equal to &quot;</span>
                        <span class="s2">&quot;the second atomic number z₂.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;The string </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">key_string</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2"> used as a key in the `off_sites` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;dictionary does not match the expected format. It should &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;represent a tuple converted to a string, like &#39;(1, 6, 0, 0)&#39;.&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span></div>



<div class="viewcode-block" id="VcrSkFeed">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.VcrSkFeed.html#tbmalt.physics.dftb.feeds.VcrSkFeed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VcrSkFeed</span><span class="p">(</span><span class="n">IntegralFeed</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Variable compression radius based DFTB Slater-Koster integral feed.</span>

<span class="sd">    This feed is similar in behaviour to the `SkFeed` but with the ability to</span>
<span class="sd">    dynamically change the compression radius in an ad-hoc manner; effectively</span>
<span class="sd">    allowing one to smoothly glide from one &quot;standard&quot; parameter set to</span>
<span class="sd">    another by adjusting the compression radius.</span>

<span class="sd">    This relies upon the existence of a variable compression radius reference</span>
<span class="sd">    database. Such as database stores a collection of parameter sets for each</span>
<span class="sd">    interaction computed with varying compression radii.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        on_sites: A torch `ParameterDict` where keys represent atomic numbers</span>
<span class="sd">            as strings, and values are torch parameters specifying the on-site</span>
<span class="sd">            energies for each orbital.</span>
<span class="sd">        off_sites: A torch `ModuleDict` containing the off-site integrals</span>
<span class="sd">            required for constructing Hamiltonian and/or overlap matrices.</span>
<span class="sd">            The keys are strings representing tuples in the format</span>
<span class="sd">            `&quot;(z₁, z₂, s₁, s₂)&quot;`, where `z₁` &amp; `z₂` are the atomic numbers</span>
<span class="sd">            of the interacting atoms (with `z₁ ≤ z₂`), and `s₁` &amp; `s₂` are</span>
<span class="sd">            their respective shell numbers. Keys must exactly match the</span>
<span class="sd">            string obtained from converting a tuple to a string, including</span>
<span class="sd">            the parentheses and spaces; for example, `&quot;(1, 6, 0, 0)&quot;`. The</span>
<span class="sd">            values are `BicubInterpSpl` instances, that provide the bond</span>
<span class="sd">            order integrals for the specified interactions as a function of</span>
<span class="sd">            not only distance but compression radius too.</span>
<span class="sd">        device: Device on which the feed object and its contents resides.</span>
<span class="sd">        dtype: dtype used by feed object.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        compression_radii: A torch `Parameter` instance specifying the</span>
<span class="sd">            compression radius of each atom in the target system. Note that</span>
<span class="sd">            this must be manually set for each target system before each call.</span>
<span class="sd">        is_local_onsite: `is_local_onsite` allows for constructing chemical</span>
<span class="sd">            environment dependent on-site energies.</span>

<span class="sd">    Warnings:</span>
<span class="sd">        It is critical to note that this class is a work in progress with many</span>
<span class="sd">        rough edges. Currently, this feed cannot operate automatically.</span>
<span class="sd">        Before this feed is invoked one must set the `compression_radii`</span>
<span class="sd">        attribute for the target system. This torch `Parameter` instance should</span>
<span class="sd">        store the compression radii for each atom in the target system. This</span>
<span class="sd">        will not automatically be set or updated at this time and thus must be</span>
<span class="sd">        done manually before every call. Additionally, this feed does not</span>
<span class="sd">        support periodic systems. These issues will be addressed later on</span>
<span class="sd">        down the line, time permitting.</span>

<span class="sd">    Notes:</span>

<span class="sd">        The splines contained within the ``off_sites`` argument must return</span>
<span class="sd">        all relevant bond order integrals; e.g. an s-s interaction should only</span>
<span class="sd">        return a single value for the σ interaction whereas a d-d interaction</span>
<span class="sd">        should return three values when interpolated (σ, π &amp; δ).</span>

<span class="sd">        Furthermore, it is critical that no duplicate interactions are present.</span>
<span class="sd">        That is to say if there is a (1, 6, 0, 0) (H[s]-C[s]) key present then</span>
<span class="sd">        there must not also be a (6, 1, 0, 0) (H[s]-C[s]) key present as they</span>
<span class="sd">        are the same interaction. To help prevent this the class will raise an</span>
<span class="sd">        error if the second atomic number is greater than the first; e.g. the</span>
<span class="sd">        key (6, 1, 0, 0) will raise an error but (1, 6, 0, 0) will not.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_sites</span><span class="p">:</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span>
                 <span class="n">off_sites</span><span class="p">:</span> <span class="n">ModuleDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Module</span><span class="p">],</span>
                 <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Pass the dtype and device to the ABC, if none are given the default</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">on_sites</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span><span class="p">,</span>
                         <span class="n">temp</span><span class="o">.</span><span class="n">device</span> <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on_sites</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;An instance of `torch.nn.ParameterDict` was expected for the &quot;</span>
                <span class="s2">&quot;attribute `on_sites`, but a standard Python `dict` was &quot;</span>
                <span class="s2">&quot;received.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">off_sites</span><span class="p">,</span> <span class="n">ModuleDict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;An instance of `torch.nn.ModuleDict` was expected for the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;attribute `off_sites`, but a/an `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">off_sites</span><span class="p">)</span><span class="si">}</span><span class="s2">` was &quot;</span>
                <span class="s2">&quot;received.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">off_sites</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__validate_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_on_sites</span><span class="p">:</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">on_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span> <span class="o">=</span> <span class="n">off_sites</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compression_radii</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_local_onsite</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">on_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameter dictionary of on-site values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_sites</span>

    <span class="nd">@on_sites</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">on_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]):</span>

        <span class="c1"># Ensure that the on-site terms are supplied via a `ParameterDict` and</span>
        <span class="c1"># not a standard Python `dict`. Using a standard `dict` would modify</span>
        <span class="c1"># the behaviour of the feed in unexpected ways.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;An instance of `torch.nn.ParameterDict` was expected for the &quot;</span>
                <span class="s2">&quot;attribute `on_sites`, but a standard Python `dict` was &quot;</span>
                <span class="s2">&quot;received.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_on_sites</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">off_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ModuleDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Module</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Module dictionary of off-site feed modules.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span>

    <span class="nd">@off_sites</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">off_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ModuleDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Module</span><span class="p">]):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ModuleDict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;An instance of `torch.nn.ModuleDict` was expected for the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;attribute `off_sites`, but a/an `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">` was &quot;</span>
                <span class="s2">&quot;received.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__validate_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_off_site_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
                         <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks (off-site only).</span>

<span class="sd">        Constructs the off-site atomic blocks using Slater-Koster integral</span>
<span class="sd">        tables.</span>

<span class="sd">        Arguments:</span>
<span class="sd">              atomic_idx_1: Indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">              atomic_idx_2: Indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                  desired interaction block.</span>
<span class="sd">              geometry: The systems to which the atomic indices relate.</span>
<span class="sd">              orbs: Orbital information associated with said systems.</span>
<span class="sd">          Returns:</span>
<span class="sd">              blocks: Requested atomic interaction sub-blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Identify atomic numbers associated with the interaction</span>
        <span class="n">z_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>
        <span class="n">z_2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="o">*</span><span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">])])</span>

        <span class="c1"># Get the species&#39; shell lists (basically a list of azimuthal numbers)</span>
        <span class="n">shells_1</span><span class="p">,</span> <span class="n">shells_2</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_1</span><span class="p">],</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_2</span><span class="p">]</span>

        <span class="c1"># Inter-atomic distance and distance vector calculator.</span>
        <span class="n">dist_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)]</span>
                    <span class="o">-</span> <span class="n">geometry</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">)])</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dist_vec</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">u_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_vec</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">dist</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Compression radii for the associated atoms</span>
        <span class="n">compression_radii</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compression_radii</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">)],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compression_radii</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)]])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Work out the width of each sub-block then use it to get the row and</span>
        <span class="c1"># column index slicers for placing sub-blocks into their atom-blocks.</span>
        <span class="n">rws</span><span class="p">,</span> <span class="n">cws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shells_2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">rws</span><span class="p">)]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cws</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="n">cws</span><span class="p">)]</span>

        <span class="c1"># Tensor to hold the resulting atomic-blocks.</span>
        <span class="n">blks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">cws</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Loop over the 1st species&#39; shells; where i &amp; l_1 are the shell&#39;s index</span>
        <span class="c1"># &amp; azimuthal numbers respectively. Then over the 2nd species&#39; shells,</span>
        <span class="c1"># but ignore sub-blocks in the lower triangle of homo-atomic blocks as</span>
        <span class="c1"># they can be constructed via symmetrisation.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_1</span><span class="p">):</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">i</span> <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">l_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shells_2</span><span class="p">[</span><span class="n">o</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="n">o</span><span class="p">):</span>
                <span class="c1"># Retrieve/interpolate the integral spline, remove any NaNs</span>
                <span class="c1"># due to extrapolation then convert to a torch tensor.</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_off_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">((</span><span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))](</span>
                    <span class="n">compression_radii</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>

                <span class="c1"># Apply the Slater-Koster transformation</span>
                <span class="n">inte</span> <span class="o">=</span> <span class="n">sub_block_rot</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">l_1</span><span class="p">,</span> <span class="n">l_2</span><span class="p">]),</span> <span class="n">u_vec</span><span class="p">,</span> <span class="n">inte</span><span class="p">)</span>

                <span class="c1"># Add the sub-blocks into their associated atom-blocks</span>
                <span class="n">blks</span><span class="p">[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inte</span>

                <span class="c1"># Add symmetrically equivalent sub-blocks (homo-atomic only)</span>
                <span class="k">if</span> <span class="n">z_1</span> <span class="o">==</span> <span class="n">z_2</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">l_1</span> <span class="o">+</span> <span class="n">l_2</span><span class="p">)</span>
                    <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[:,</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inte</span> <span class="o">*</span> <span class="n">sign</span>

        <span class="k">return</span> <span class="n">blks</span>

<div class="viewcode-block" id="VcrSkFeed.blocks">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.VcrSkFeed.html#tbmalt.physics.dftb.feeds.VcrSkFeed.blocks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
               <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks using SK-integral tables.</span>

<span class="sd">        Returns the atomic blocks associated with the atoms in ``atomic_idx_1``</span>
<span class="sd">        interacting with those in ``atomic_idx_2`` splines and Slater-Koster</span>
<span class="sd">        transformations. This is the base method used in DFTB calculations.</span>
<span class="sd">        Note that The № of interaction blocks returned will be equal to the</span>
<span class="sd">        length of the two index lists; i.e. *not* one for every combination.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            atomic_idx_1: Indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            atomic_idx_2: Indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            geometry: The systems to which the atomic indices relate.</span>
<span class="sd">            orbs: Orbital information associated with said systems.</span>

<span class="sd">        Returns:</span>
<span class="sd">            blocks: Requested atomic interaction sub-blocks.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compression_radii</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The `compression_radii` attribute must be set for the target &quot;</span>
                <span class="s2">&quot;system before this method can be called.&quot;</span><span class="p">)</span>

        <span class="c1"># Get the atomic numbers of the atoms</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span>
        <span class="n">zs_1</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">)]</span>
        <span class="n">zs_2</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="o">*</span><span class="n">bT2</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)]</span>

        <span class="c1"># Ensure all interactions are between identical species pairs.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs_1</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Atoms in atomic_idx_1 must be the same species&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs_2</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Atoms in atomic_idx_2 must be the same species&#39;</span><span class="p">)</span>

        <span class="c1"># Atomic numbers of the species in list 1 and 2</span>
        <span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span> <span class="o">=</span> <span class="n">zs_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zs_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># C-N and N-C are the same interaction: choice has been made to have</span>
        <span class="c1"># only one set of splines for each species pair. Thus, the two lists</span>
        <span class="c1"># may need to be swapped.</span>
        <span class="k">if</span> <span class="n">z_1</span> <span class="o">&gt;</span> <span class="n">z_2</span><span class="p">:</span>
            <span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span> <span class="o">=</span> <span class="n">atomic_idx_2</span><span class="p">,</span> <span class="n">atomic_idx_1</span>
            <span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span> <span class="o">=</span> <span class="n">z_2</span><span class="p">,</span> <span class="n">z_1</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Construct the tensor into which results are to be placed</span>
        <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">n_orbs_on_species</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">z_1</span><span class="p">,</span> <span class="n">z_2</span><span class="p">)))</span>
        <span class="n">blks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">),</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Identify which are on-site blocks and which are off-site</span>
        <span class="n">on_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_blocks</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">)</span>
        <span class="n">mask_shell</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">z_1</span><span class="o">.</span><span class="n">item</span><span class="p">())])</span><span class="o">.</span><span class="n">bool</span><span class="p">()</span>
        <span class="n">mask_shell</span><span class="p">[:(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="o">.</span><span class="n">shell_dict</span><span class="p">[</span><span class="n">z_1</span><span class="o">.</span><span class="n">item</span><span class="p">()]))</span>
                     <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Construct the on-site blocks (if any are present)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">on_site</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_local_onsite</span><span class="p">:</span>
                <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">z_1</span><span class="o">.</span><span class="n">item</span><span class="p">())][</span><span class="n">mask_shell</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">z_1</span><span class="o">.</span><span class="n">item</span><span class="p">())],</span> <span class="n">dim1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Interactions between images need to be considered for on-site</span>
            <span class="c1"># blocks with pbc.</span>
            <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_periodic</span><span class="p">:</span>
                <span class="n">_on_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pe_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">periodicity</span><span class="p">,</span> <span class="n">onsite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">blks</span><span class="p">[</span><span class="n">on_site</span><span class="p">]</span> <span class="o">+</span> <span class="n">_on_site</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="o">~</span><span class="n">on_site</span><span class="p">):</span>  <span class="c1"># Then the off-site blocks</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_periodic</span><span class="p">:</span>
                <span class="n">blks</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_off_site_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blks</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pe_blocks</span><span class="p">(</span>
                    <span class="n">atomic_idx_1</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span> <span class="n">atomic_idx_2</span><span class="p">[</span><span class="o">~</span><span class="n">on_site</span><span class="p">],</span>
                    <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">periodicity</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flip</span><span class="p">:</span>  <span class="c1"># If the atoms were switched, then a transpose is required.</span>
            <span class="n">blks</span> <span class="o">=</span> <span class="n">blks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">blks</span></div>


<div class="viewcode-block" id="VcrSkFeed.from_database">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.VcrSkFeed.html#tbmalt.physics.dftb.feeds.VcrSkFeed.from_database">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_database</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">target</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">],</span>
            <span class="n">requires_grad_onsite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;VcrSkFeed&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Instantiate instance from an HDF5 database of Slater-Koster files.</span>

<span class="sd">        Instantiate a `SkFeed` instance for the specified elements using</span>
<span class="sd">        integral tables contained within a Slater-Koster HDF5 database.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            path: Path to the HDF5 file from which integrals should be taken.</span>
<span class="sd">            species: Integrals will only be loaded for the requested species.</span>
<span class="sd">            target: Specifies which integrals should be loaded, options are</span>
<span class="sd">                &quot;hamiltonian&quot; and &quot;overlap&quot;.</span>
<span class="sd">            requires_grad_onsite: When set to `True` gradient tracking will be</span>
<span class="sd">                enabled for the on-site parameters. This flag is ignored for</span>
<span class="sd">                the overlap matrix case as its on-site terms are always unity.</span>
<span class="sd">                [DEFAULT=`False`]</span>
<span class="sd">            device: Device on which the feed object and its contents resides.</span>
<span class="sd">            dtype: dtype used by feed object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            vcrsk_feed: A `VcrSkFeed` instance with the requested integrals.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># As C-H &amp; C-H interactions are the same only one needs to be loaded.</span>
        <span class="c1"># Thus, only off-site interactions where z₁≤z₂ are generated. However,</span>
        <span class="c1"># integrals are split over the two Slater-Koster tables, thus both must</span>
        <span class="c1"># be loaded.</span>

        <span class="c1"># Ensure a valid target is selected</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">]:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid target selected; &#39;</span>
                       <span class="s1">&#39;options are &quot;hamiltonian&quot; or &quot;overlap&quot;&#39;</span><span class="p">)</span>

        <span class="n">on_sites</span> <span class="o">=</span> <span class="n">ParameterDict</span><span class="p">()</span>
        <span class="n">off_sites</span> <span class="o">=</span> <span class="n">ModuleDict</span><span class="p">()</span>

        <span class="c1"># The species list must be sorted to ensure that the lowest atomic</span>
        <span class="c1"># number comes first in the species pair.</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">species</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>

            <span class="n">skf</span> <span class="o">=</span> <span class="n">VCRSkf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Loop over the off-site interactions &amp; construct the splines.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">skf</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">off_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">pair</span> <span class="o">+</span> <span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">BicubInterpSpl</span><span class="p">(</span>
                    <span class="n">skf</span><span class="o">.</span><span class="n">compression_radii</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">value</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">skf</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>

            <span class="c1"># The X-Y.skf file may not contain all information. Thus, some info</span>
            <span class="c1"># must be loaded from its Y-X counterpart.</span>
            <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">skf_2</span> <span class="o">=</span> <span class="n">VCRSkf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">pair</span><span class="p">)),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">skf_2</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pair</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="n">key</span><span class="p">),))</span>
                        <span class="n">off_sites</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">BicubInterpSpl</span><span class="p">(</span>
                            <span class="n">skf_2</span><span class="o">.</span><span class="n">compression_radii</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">value</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">skf</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Construct the onsite interactions</span>
                <span class="c1"># Repeated so there&#39;s 1 value per orbital not just per shell.</span>
                <span class="n">on_sites_vals</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
                    <span class="n">skf</span><span class="o">.</span><span class="n">on_sites</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span>
                        <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skf</span><span class="o">.</span><span class="n">on_sites</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad_onsite</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="s1">&#39;overlap&#39;</span><span class="p">:</span>  <span class="c1"># use an identity matrix for S</span>
                    <span class="c1"># Auto-grad tracking is always disabled as the values can</span>
                    <span class="c1"># never be anything other than one.</span>
                    <span class="n">on_sites_vals</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
                        <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">on_sites_vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span>
                        <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">on_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">on_sites_vals</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">on_sites</span><span class="p">,</span> <span class="n">off_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="n">chemical_symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
            <span class="nb">sorted</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="p">])</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">elements</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__validate_key</span><span class="p">(</span><span class="n">key_string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate format of an off-site module-dictionary key.</span>

<span class="sd">        Validates that the provided string matches the expected format of a tuple</span>
<span class="sd">        converted to a string, i.e., &quot;(z₁, z₂, s₁, s₂)&quot;.</span>

<span class="sd">        The string must:</span>
<span class="sd">        - Start with a left parenthesis &#39;(&#39;</span>
<span class="sd">        - End with a right parenthesis &#39;)&#39;</span>
<span class="sd">        - Contain exactly four comma-separated integers</span>
<span class="sd">        - Have exactly one space after each comma</span>
<span class="sd">        - Ensure that z₁ ≤ z₂</span>

<span class="sd">        Arguments:</span>
<span class="sd">            key_string: The string to validate.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If any of the validation checks fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Check if the string starts with &#39;(&#39; and ends with &#39;)&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">key_string</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key_string</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)):</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;The string must start with &#39;(&#39; and end with &#39;)&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remove the parentheses</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">key_string</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Define the expected pattern</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^(\d+), (\d+), (\d+), (\d+)$&#39;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;The string must contain exactly four comma-separated integers, &quot;</span>
                    <span class="s2">&quot;with exactly one space after each comma.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>

                <span class="c1"># Check if z₁ ≤ z₂</span>
                <span class="k">if</span> <span class="n">z1</span> <span class="o">&gt;</span> <span class="n">z2</span><span class="p">:</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;The first atomic number z₁ must be less than or equal to &quot;</span>
                        <span class="s2">&quot;the second atomic number z₂.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;The string </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">key_string</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2"> used as a key in the `off_sites` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;dictionary does not match the expected format. It should &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;represent a tuple converted to a string, like &#39;(1, 6, 0, 0)&#39;.&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span></div>



<div class="viewcode-block" id="SkfOnSiteFeed">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkfOnSiteFeed.html#tbmalt.physics.dftb.feeds.SkfOnSiteFeed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SkfOnSiteFeed</span><span class="p">(</span><span class="n">Feed</span><span class="p">):</span>

<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;On-site term feed backed by shell-resolved SKF data.</span>

<span class="sd">    This feed provides access to azimuthally (shell-)resolved on-site terms</span>
<span class="sd">    read from Slater–Koster parameter files and exposes them in a form suitable</span>
<span class="sd">    for DFTB matrix construction. A single optimisable value is stored per</span>
<span class="sd">    subshell (e.g. one value for s, one for p, one for d), and it is expanded</span>
<span class="sd">    on demand to one value per magnetic orbital within :meth:`forward` by</span>
<span class="sd">    repeating according to the multiplicity :math:`(2\ell + 1)`.</span>


<span class="sd">    Arguments:</span>
<span class="sd">        on_sites: A :class:`torch.nn.ParameterDict` whose keys are atomic</span>
<span class="sd">            numbers represented as strings (e.g. `&quot;1&quot;`, `&quot;6&quot;`) and whose values</span>
<span class="sd">            are :class:`torch.nn.Parameter` objects containing the azimuthally</span>
<span class="sd">            resolved on-site terms for the corresponding species. One scalar</span>
<span class="sd">            parameter per subshell is expected (e.g. `[s]`, `[s, p]`,</span>
<span class="sd">            `[s, p, d]`).</span>
<span class="sd">        azimuthal_numbers: A dictionary in which keys are atomic numbers (as</span>
<span class="sd">            strings) and values are 1-D integer tensors giving the azimuthal</span>
<span class="sd">            quantum number `l` for each azimuthally resolved on-site term in</span>
<span class="sd">            ``on_sites``. When this argument is omitted, a minimal, valence-</span>
<span class="sd">            -only shell ordering is assumed and `l` is inferred as</span>
<span class="sd">            `torch.arange(len(on_site))` for the corresponding species. The</span>
<span class="sd">            `l` values are used solely to expand each azimuthal on-site term</span>
<span class="sd">            into its magnetic-orbital multiplicity `(2l + 1)` within `forward`.</span>
<span class="sd">            In this way a single subshell parameter (e.g. one d value) is</span>
<span class="sd">            repeated to yield the required number of magnetic entries (five</span>
<span class="sd">            for d), avoiding their separate optimisation. [DEFAULT=`None`]</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from torch import tensor</span>
<span class="sd">        &gt;&gt;&gt; from torch.nn import Parameter, ParameterDict</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import SkfOnSiteFeed</span>
<span class="sd">        &gt;&gt;&gt; on = ParameterDict({</span>
<span class="sd">        ...     &quot;1&quot;: Parameter(tensor([-0.5])),          # H: [s]</span>
<span class="sd">        ...     &quot;6&quot;: Parameter(tensor([-0.3, -0.2]))     # C: [s, p]</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; feed = SkfOnSiteFeed(on)       # azimuthal_numbers inferred</span>
<span class="sd">        &gt;&gt;&gt; feed(&quot;1&quot;)                      # s → (2*0+1)=1 value</span>
<span class="sd">        tensor([-0.5000])</span>
<span class="sd">        &gt;&gt;&gt; feed(&quot;6&quot;)                      # s, p → 1 + 3 values</span>
<span class="sd">        tensor([-0.3000, -0.2000, -0.2000, -0.2000])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">on_sites</span><span class="p">:</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span>
            <span class="n">azimuthal_numbers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Ensure that the on-site terms are supplied via a `ParameterDict`.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on_sites</span><span class="p">,</span> <span class="n">ParameterDict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Expected argument `on_sites` to be of type `ParameterDict` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but encountered type `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">on_sites</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` instead.&quot;</span><span class="p">)</span>

        <span class="c1"># If no azimuthal numbers are provided then the on-site terms are</span>
        <span class="c1"># assumed to correspond to a minimal, valence-only ordered &quot;basis&quot;.</span>
        <span class="k">if</span> <span class="n">azimuthal_numbers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">azimuthal_numbers</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">species</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">on_site</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">on_site</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">species</span><span class="p">,</span> <span class="n">on_site</span> <span class="ow">in</span> <span class="n">on_sites</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># If an azimuthal number dictionary has been provided then ensure the</span>
        <span class="c1"># corresponding tensors in the two dictionaries are on the same device</span>
        <span class="c1"># for each species and that types are as expected.</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value_1</span> <span class="ow">in</span> <span class="n">on_sites</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">value_2</span> <span class="o">=</span> <span class="n">azimuthal_numbers</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_2</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;A value of invalid type has been encountered in the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`azimuthal_numbers` dictionary: expected type &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`Tensor`, but encountered `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value_2</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;instead (key:</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">value_1</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="n">value_2</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Inconsistent device placement detected for atomic &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;species </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: `on_sites` tensor resides on &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value_1</span><span class="o">.</span><span class="n">device</span><span class="si">}</span><span class="s2">, but `azimuthal_numbers` tensor &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;resides on </span><span class="si">{</span><span class="n">value_2</span><span class="o">.</span><span class="n">device</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span> <span class="o">=</span> <span class="n">on_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuthal_numbers</span> <span class="o">=</span> <span class="n">azimuthal_numbers</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">device</span>

<div class="viewcode-block" id="SkfOnSiteFeed.forward">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkfOnSiteFeed.html#tbmalt.physics.dftb.feeds.SkfOnSiteFeed.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return per-orbital on-site terms for a given species.</span>

<span class="sd">        The azimuthally resolved on-site values stored in `on_sites` are</span>
<span class="sd">        expanded to one value per magnetic orbital by repeating each subshell</span>
<span class="sd">        term according to its magnetic multiplicity :math:`(2\ell + 1)`. The</span>
<span class="sd">        species identifier is normalised to a string before lookup.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            species: Atomic number of the species for which on-site terms are</span>
<span class="sd">                requested. May be provided as an `int` (e.g. `6`) or a</span>
<span class="sd">                string (e.g. `&quot;6&quot;`).</span>

<span class="sd">        Returns:</span>
<span class="sd">            on_site: A 1-D :class:`torch.Tensor` containing one on-site value</span>
<span class="sd">                for each magnetic orbital of the requested species. Its length</span>
<span class="sd">                equals `sum(2*l + 1 for l in azimuthal_numbers[species])`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure the species key is a string.</span>
        <span class="n">species</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">species</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">species</span>

        <span class="c1"># Fetch the azimuthally resolved on-site terms from the `on_sites`</span>
        <span class="c1"># parameter dictionary and repeat each term so that there is one value</span>
        <span class="c1"># for each subshell. For example a term corresponding to a p-shell</span>
        <span class="c1"># would be repeated three times, once for each of the associated</span>
        <span class="c1"># magnetic moments p_x, p_y, and p_z.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="p">[</span><span class="n">species</span><span class="p">]</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">azimuthal_numbers</span><span class="p">[</span><span class="n">species</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="SkfOnSiteFeed.from_database">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkfOnSiteFeed.html#tbmalt.physics.dftb.feeds.SkfOnSiteFeed.from_database">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_database</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">target</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">],</span>
            <span class="n">requires_grad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate instance from an HDF5 Slater–Koster database.</span>

<span class="sd">        On-site terms are read for the requested species from an HDF5 SKF</span>
<span class="sd">        database and stored as azimuthally (subshell) resolved parameters.</span>
<span class="sd">        A single value per subshell is retained (e.g. one for s, one for p),</span>
<span class="sd">        and expansion to one value per magnetic orbital is performed on demand</span>
<span class="sd">        in :meth:`forward`. When the overlap target is selected, all on-site</span>
<span class="sd">        terms are set to unity so that identity blocks are emitted.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            path: Path to the HDF5 file from which on-sites should be taken.</span>
<span class="sd">            species: On-sites will only be loaded for the requested species.</span>
<span class="sd">            target: Specifies which set of on-site terms is to be loaded.</span>
<span class="sd">                Options are `&quot;hamiltonian&quot;` and `&quot;overlap&quot;`. For overlap,</span>
<span class="sd">                the on-site terms are set to ones (identity) and are never</span>
<span class="sd">                differentiable.</span>
<span class="sd">            requires_grad: If `True`, gradient tracking is enabled for the</span>
<span class="sd">                Hamiltonian on-site parameters. This flag is ignored when</span>
<span class="sd">                ``target`` is set to `&quot;overlap&quot;` since those terms are always</span>
<span class="sd">                unity. [DEFAULT=`False`]</span>
<span class="sd">            device: Device on which the feed object and its contents reside.</span>
<span class="sd">            dtype: dtype used by feed object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            on_sites: A `SkfOnSiteFeed` instance containing the requested</span>
<span class="sd">                on-site terms for the specified species.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torch import tensor</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import SkfOnSiteFeed</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.tools.downloaders import download_dftb_parameter_set</span>
<span class="sd">            &gt;&gt;&gt; url = &#39;https://github.com/dftbparams/auorg/releases/download/v1.1.0/auorg-1-1.tar.xz&#39;</span>
<span class="sd">            &gt;&gt;&gt; path = &quot;auorg.h5&quot;</span>
<span class="sd">            &gt;&gt;&gt; download_dftb_parameter_set(url, path)</span>
<span class="sd">            &gt;&gt;&gt; feed = SkfOnSiteFeed.from_database(path, [1, 6, 79], &quot;hamiltonian&quot;)</span>
<span class="sd">            &gt;&gt;&gt; feed(&quot;1&quot;)</span>
<span class="sd">            tensor([-0.2386])</span>
<span class="sd">            &gt;&gt;&gt; feed(&quot;6&quot;)</span>
<span class="sd">            tensor([-0.5049, -0.1944, -0.1944, -0.1944])</span>
<span class="sd">            &gt;&gt;&gt; feed(&quot;79&quot;)</span>
<span class="sd">            tensor([-0.2108, -0.0279, -0.0279, -0.0279,</span>
<span class="sd">                    -0.2532, -0.2532, -0.2532, -0.2532,</span>
<span class="sd">                    -0.2532])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure a valid target is selected</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">]:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid target selected; &#39;</span>
                       <span class="s1">&#39;options are &quot;hamiltonian&quot; or &quot;overlap&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># Loop over each species, load the corresponding on-site terms from the</span>
        <span class="c1"># skf file, and add it to the `on_sites` dictionary.</span>
        <span class="n">on_sites</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">species</span><span class="p">:</span>

            <span class="c1"># Read the on-site Hamiltonian terms from the relevant skf file.</span>
            <span class="n">on_site</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
                <span class="n">Skf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">on_sites</span><span class="p">,</span>
                <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">)</span>

            <span class="c1"># On-site terms for the overlap matrix are all set one as they</span>
            <span class="c1"># should just emit the identity matrix. Auto-grad tracking is</span>
            <span class="c1"># always disabled for overlap elements as the value can never</span>
            <span class="c1"># be anything other than one.</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="s1">&#39;overlap&#39;</span><span class="p">:</span>
                <span class="n">on_site</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">on_site</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

            <span class="n">on_sites</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">on_site</span>

        <span class="c1"># Convert the on_sites dictionary into a parameter dictionary and</span>
        <span class="c1"># use it to instantiate a new SkfOnSiteFeed.</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">ParameterDict</span><span class="p">(</span><span class="n">on_sites</span><span class="p">))</span></div>


<div class="viewcode-block" id="SkfOnSiteFeed.to">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkfOnSiteFeed.html#tbmalt.physics.dftb.feeds.SkfOnSiteFeed.to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SkfOnSiteFeed</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return a copy of the feed placed on the specified device.</span>


<span class="sd">        Args:</span>
<span class="sd">            device: Device to which all associated tensor should be moved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            on_site_feed: A copy of the `SkfOnSiteFeed` instance placed on</span>
<span class="sd">                the specified device.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">on_sites</span> <span class="o">=</span> <span class="n">ParameterDict</span><span class="p">(</span>
            <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_sites</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

        <span class="n">azimuthal_numbers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuthal_numbers</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">on_sites</span><span class="p">,</span> <span class="n">azimuthal_numbers</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SkfOccupationFeed">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkfOccupationFeed.html#tbmalt.physics.dftb.feeds.SkfOccupationFeed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SkfOccupationFeed</span><span class="p">(</span><span class="n">Feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Occupations feed entity that derives its data from a skf file.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        occupancies: A PyTorch parameter dictionary specifying the angular-</span>
<span class="sd">            -momenta resolved occupancies, keyed by atomic numbers (as</span>
<span class="sd">            strings) and valued by parameters. Dictionary keys must be strings</span>
<span class="sd">            as required by the PyTorch `ParameterDict` structure.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from torch import tensor</span>
<span class="sd">        &gt;&gt;&gt; from torch.nn import ParameterDict</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import SkfOccupationFeed</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt import OrbitalInfo</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Shell resolved occupancies — {H: [s], C: [s, p]}</span>
<span class="sd">        &gt;&gt;&gt; occupation_feed = SkfOccupationFeed(ParameterDict({</span>
<span class="sd">        ...     &quot;1&quot;: tensor([1.]), &quot;6&quot;: tensor([2., 2.])}))</span>
<span class="sd">        &gt;&gt;&gt; # Orbital information instance for CH4</span>
<span class="sd">        &gt;&gt;&gt; orbs = OrbitalInfo(</span>
<span class="sd">        ...     tensor([6, 1, 1, 1, 1]), {1: [0], 6: [0, 1]})</span>
<span class="sd">        &gt;&gt;&gt; # Interrogate the occupancy feed</span>
<span class="sd">        &gt;&gt;&gt; occs = occupation_feed(orbs)</span>
<span class="sd">        &gt;&gt;&gt; # The feed will always return one occupancy value per-orbital.</span>
<span class="sd">        &gt;&gt;&gt; print(occs)</span>
<span class="sd">        tensor([2.000, 0.667, 0.667, 0.667, 1.000, 1.000, 1.000, 1.000])</span>

<span class="sd">    Notes:</span>
<span class="sd">        Note that this method discriminates between orbitals based only on</span>
<span class="sd">        the azimuthal number of the orbital &amp; the species to which it belongs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Developer&#39;s Notes:</span>
    <span class="c1"># This class will be abstracted and extended to allow for specification</span>
    <span class="c1"># via shell number which will avoid the current limits which only allow</span>
    <span class="c1"># for minimal orbs sets.</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">occupancies</span><span class="p">:</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">occupancies</span> <span class="o">=</span> <span class="n">occupancies</span>

        <span class="c1"># Occupancy values must be supplied via a PyTorch `ParameterDict`.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">occupancies</span><span class="p">,</span> <span class="n">ParameterDict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Occupancies must be stored within a `torch.nn.ParameterDict` &quot;</span>
                <span class="s2">&quot;entity. This allows PyTorch to a automatically detect valid &quot;</span>
                <span class="s2">&quot;optimisation targets as and when necessary.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Floating point dtype used by `SkfOccupationFeed` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancies</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The device on which the `SkfOccupationFeed` object resides.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occupancies</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span>

<div class="viewcode-block" id="SkfOccupationFeed.to">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkfOccupationFeed.html#tbmalt.physics.dftb.feeds.SkfOccupationFeed.to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SkfOccupationFeed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the `SkfOccupationFeed` on the specified device.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            device: Device to which all associated tensor should be moved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            occupancy_feed: A copy of the `SkfOccupationFeed` instance placed</span>
<span class="sd">                on the specified device.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">ParameterDict</span><span class="p">({</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancies</span><span class="o">.</span><span class="n">items</span><span class="p">()}))</span></div>


<div class="viewcode-block" id="SkfOccupationFeed.forward">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkfOccupationFeed.html#tbmalt.physics.dftb.feeds.SkfOccupationFeed.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shell resolved occupancies.</span>

<span class="sd">        This returns the shell resolved occupancies for the neutral atom in the</span>
<span class="sd">        ground state. The resulting values are derived from static occupancy</span>
<span class="sd">        parameters read in from an SKF formatted file.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            orbs: orbs objects for the target systems.</span>

<span class="sd">        Returns:</span>
<span class="sd">            occupancies: shell resolved occupancies.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Construct a pair of arrays, &#39;zs&#39; &amp; `ls`, that can be used to look up</span>
        <span class="c1"># the species and shell number for each orbital.</span>
        <span class="n">z_list</span><span class="p">,</span> <span class="n">l_list</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_ls</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">prepeat_interleave</span><span class="p">(</span><span class="n">z_list</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">n_orbs_on_species</span><span class="p">(</span><span class="n">z_list</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ls</span> <span class="o">=</span> <span class="n">prepeat_interleave</span><span class="p">(</span><span class="n">l_list</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">orbs_per_shell</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Ensure occupancies exist for all requests species</span>
        <span class="n">supported</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancies</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="c1"># The {0,} set is subtracted from the requested set to ensure that</span>
        <span class="c1"># padding values are not mistaken for &quot;real&quot; species.</span>
        <span class="n">requested</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">orbs</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="mi">0</span><span class="p">,}</span>
        <span class="n">unsupported</span> <span class="o">=</span> <span class="n">requested</span> <span class="o">-</span> <span class="n">supported</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unsupported</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown species — `SkfOccupationFeed` instance contains &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;parameters only for </span><span class="si">{</span><span class="n">supported</span><span class="si">}</span><span class="s2">, but encountered &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">unsupported</span><span class="si">}</span><span class="s2">. Ensure occupancies values are given for all &quot;</span>
                <span class="s2">&quot;necessary species.&quot;</span><span class="p">)</span>

        <span class="c1"># Tensor into which the results will be placed</span>
        <span class="n">occupancies</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Loop over all available occupancy information</span>
        <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">occs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occupancies</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># As the atomic number keys in the occupancies dictionaries are</span>
            <span class="c1"># stored as strings, for PyTorch compatability reasons, they need</span>
            <span class="c1"># to be cast back into integers.</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="c1"># Loop over each shell for species &#39;z&#39;</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">occ</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">occs</span><span class="p">):</span>
                <span class="c1"># And assign the associated occupancy where appropriate</span>
                <span class="n">occupancies</span><span class="p">[(</span><span class="n">zs</span> <span class="o">==</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ls</span> <span class="o">==</span> <span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">occ</span>

        <span class="c1"># Divide the occupancy by the number of shells</span>
        <span class="k">return</span> <span class="n">occupancies</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="SkfOccupationFeed.from_database">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.SkfOccupationFeed.html#tbmalt.physics.dftb.feeds.SkfOccupationFeed.from_database">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_database</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SkfOccupationFeed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate an `SkfOccupationFeed` instance from an HDF5 database.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            path: path to the HDF5 file in which the skf file data is stored.</span>
<span class="sd">            species: species for which occupancies are to be loaded.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            device: Device on which to place tensors. [DEFAULT=None]</span>
<span class="sd">            dtype: dtype to be used for floating point tensors. [DEFAULT=None]</span>
<span class="sd">            requires_grad: boolean indicating if gradient tracking should be</span>
<span class="sd">                enabled for the occupancies. If enabled, the relevant</span>
<span class="sd">                dictionaries and tensors will be converted into `ParameterDict`</span>
<span class="sd">                and `Parameter` instances respectively. [DEFAULT=False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            occupancy_feed: An `SkfOccupationFeed` instance containing the</span>
<span class="sd">                requested occupancy information.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import torch</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt import OrbitalInfo</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import SkfOccupationFeed</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.tools.downloaders import download_dftb_parameter_set</span>
<span class="sd">            &gt;&gt;&gt; torch.set_default_dtype(torch.float64)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Download the auorg-1-1 parameter set</span>
<span class="sd">            &gt;&gt;&gt; url = &#39;https://github.com/dftbparams/auorg/releases/download/v1.1.0/auorg-1-1.tar.xz&#39;</span>
<span class="sd">            &gt;&gt;&gt; path = &quot;auorg.h5&quot;</span>
<span class="sd">            &gt;&gt;&gt; download_dftb_parameter_set(url, path)</span>
<span class="sd">            &gt;&gt;&gt; # Definition of feeds</span>
<span class="sd">            &gt;&gt;&gt; o_feed = SkfOccupationFeed.from_database(path, [1, 6])</span>
<span class="sd">            &gt;&gt;&gt; shell_dict = {1: [0], 6: [0, 1]}</span>
<span class="sd">            &gt;&gt;&gt; # Occupancy information of an example system</span>
<span class="sd">            &gt;&gt;&gt; print(o_feed(OrbitalInfo(torch.tensor([6, 1, 1, 1, 1]), shell_dict)))</span>
<span class="sd">            tensor([2.0000, 0.6667, 0.6667, 0.6667,</span>
<span class="sd">                    1.0000, 1.0000, 1.0000, 1.0000])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">requires_grad</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;requires_grad&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_occupations</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># Read occupancy values for the target species from the associated</span>
            <span class="c1"># Slater-Koster parameter file.</span>
            <span class="n">occupations</span> <span class="o">=</span> <span class="n">Skf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">occupations</span>

            <span class="c1"># `Tensor` -&gt; `Parameter` cast done manually now to give control</span>
            <span class="c1"># over the `requires_grad` option.</span>
            <span class="k">return</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">occupations</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">ParameterDict</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="n">get_occupations</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">species</span><span class="p">}))</span></div>
</div>



<div class="viewcode-block" id="HubbardFeed">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.HubbardFeed.html#tbmalt.physics.dftb.feeds.HubbardFeed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HubbardFeed</span><span class="p">(</span><span class="n">Feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Hubbard U feed entity that derives its data from a skf file.</span>

<span class="sd">    This provides a feed based method by which traditional DFTB Hubbard-U</span>
<span class="sd">    values can be accessed.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        hubbard_us: A PyTorch parameter dictionary specifying the angular-</span>
<span class="sd">            -momenta resolved Hubbard-Us, keyed by atomic numbers (as strings)</span>
<span class="sd">            and valued by parameters. Dictionary keys must be strings</span>
<span class="sd">            as required by the PyTorch `ParameterDict` structure.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from torch import tensor</span>
<span class="sd">        &gt;&gt;&gt; from torch.nn import ParameterDict</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import HubbardFeed</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt import OrbitalInfo</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Shell resolved Hubbard-U feed — {H: [s], C: [s, p]}</span>
<span class="sd">        &gt;&gt;&gt; hubbard_u_feed = HubbardFeed(ParameterDict({</span>
<span class="sd">        ...     &quot;1&quot;: tensor([0.4196]), &quot;6&quot;: tensor([0.3647, 0.3647])}))</span>
<span class="sd">        &gt;&gt;&gt; # Orbital information instance for CH4 (shell resolved)</span>
<span class="sd">        &gt;&gt;&gt; orbs = OrbitalInfo(</span>
<span class="sd">        ...     tensor([6, 1, 1, 1, 1]), {1: [0], 6: [0, 1]}, True)</span>
<span class="sd">        &gt;&gt;&gt; # Interrogate the Hubbard-U feed</span>
<span class="sd">        &gt;&gt;&gt; l_resolved_us = hubbard_u_feed(orbs)</span>
<span class="sd">        &gt;&gt;&gt; # The feed returns one Hubbard-U value per-shell as the OrbitalInfo</span>
<span class="sd">        &gt;&gt;&gt; # entity is shell resolved. If it were atom resolved, then it would</span>
<span class="sd">        &gt;&gt;&gt; # yield only one value per-atom.</span>
<span class="sd">        &gt;&gt;&gt; print(l_resolved_us)</span>
<span class="sd">        tensor([0.3647, 0.3647, 0.4196, 0.4196, 0.4196, 0.4196])</span>

<span class="sd">    Notes:</span>
<span class="sd">        Note that this method discriminates between orbitals based only on</span>
<span class="sd">        the azimuthal number of the orbital &amp; the species to which it belongs.</span>

<span class="sd">    Todo:</span>
<span class="sd">        Add a test that throws an error if a shell resolved orbs is provided but</span>
<span class="sd">        `hubbard_u` is found to only be atom resolved; and vise versa. The skf</span>
<span class="sd">        database should also instruct the loader whether it is shell-resolved.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hubbard_us</span><span class="p">:</span> <span class="n">ParameterDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hubbard_us</span> <span class="o">=</span> <span class="n">hubbard_us</span>

        <span class="c1"># Hubbard-U values must be supplied via a PyTorch `ParameterDict`.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hubbard_us</span><span class="p">,</span> <span class="n">ParameterDict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Hubbard-Us must be stored within a `torch.nn.ParameterDict` &quot;</span>
                <span class="s2">&quot;entity. This allows PyTorch to a automatically detect valid &quot;</span>
                <span class="s2">&quot;optimisation targets as and when necessary.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Floating point dtype used by the `HubbardFeed` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hubbard_us</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The device on which the `HubbardFeed` object resides.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hubbard_us</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">device</span>

<div class="viewcode-block" id="HubbardFeed.to">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.HubbardFeed.html#tbmalt.physics.dftb.feeds.HubbardFeed.to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HubbardFeed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the `HubbardFeed` on the specified device.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            device: Device to which all associated tensor should be moved.</span>

<span class="sd">        Returns:</span>
<span class="sd">            hubbard_u_feed: A copy of the `HubbardFeed` instance placed</span>
<span class="sd">                on the specified device.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">ParameterDict</span><span class="p">({</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hubbard_us</span><span class="o">.</span><span class="n">items</span><span class="p">()}))</span></div>


<div class="viewcode-block" id="HubbardFeed.forward">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.HubbardFeed.html#tbmalt.physics.dftb.feeds.HubbardFeed.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hubbard U values.</span>

<span class="sd">        This returns the Hubbard U values for the atom.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            orbs: orbs objects for the target systems.</span>

<span class="sd">        Returns:</span>
<span class="sd">            hubbard_us: Hubbard U values, either shell or atom resolved</span>
<span class="sd">                depending on status of `orbs.shell_resolved`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Construct a pair of arrays, &#39;zs&#39; &amp; `ls`, that can be used to look up</span>
        <span class="c1"># the species and shell number for each orbital.</span>
        <span class="n">z_list</span><span class="p">,</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_ls</span>

        <span class="c1"># Ensure Hubbard-U parameters exist for all requests species</span>
        <span class="n">supported</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hubbard_us</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="c1"># The {0,} set is subtracted from the requested set to ensure that</span>
        <span class="c1"># padding values are not mistaken for &quot;real&quot; species.</span>
        <span class="n">requested</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">orbs</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="mi">0</span><span class="p">,}</span>
        <span class="n">unsupported</span> <span class="o">=</span> <span class="n">requested</span> <span class="o">-</span> <span class="n">supported</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unsupported</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown species — `HubbardFeed` instance contains parameters &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;only for </span><span class="si">{</span><span class="n">supported</span><span class="si">}</span><span class="s2">, but encountered </span><span class="si">{</span><span class="n">unsupported</span><span class="si">}</span><span class="s2">. Ensure &quot;</span>
                <span class="s2">&quot;Hubbard-U values are given for all necessary species.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orbs</span><span class="o">.</span><span class="n">shell_resolved</span><span class="p">:</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="n">prepeat_interleave</span><span class="p">(</span><span class="n">z_list</span><span class="p">,</span> <span class="n">orbs</span><span class="o">.</span><span class="n">n_shells_on_species</span><span class="p">(</span><span class="n">z_list</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Tensor into which the results will be placed</span>
            <span class="n">hubbard_us</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Loop over all available Hubbard-U information</span>
            <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">us</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hubbard_us</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="c1"># Loop over each shell for species &#39;z&#39;</span>
                <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">us</span><span class="p">):</span>
                    <span class="c1"># And assign the associated Hubbard-Us where appropriate</span>
                    <span class="n">hubbard_us</span><span class="p">[(</span><span class="n">zs</span> <span class="o">==</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ls</span> <span class="o">==</span> <span class="n">l</span><span class="p">)]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hubbard_us</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z_list</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">us</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hubbard_us</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">hubbard_us</span><span class="p">[</span><span class="n">z_list</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">z</span><span class="p">)]</span> <span class="o">=</span> <span class="n">us</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">hubbard_us</span></div>


<div class="viewcode-block" id="HubbardFeed.from_database">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.HubbardFeed.html#tbmalt.physics.dftb.feeds.HubbardFeed.from_database">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_database</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HubbardFeed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate an `HubbardFeed` instance from an HDF5 database.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            path: path to the HDF5 file in which the skf file data is stored.</span>
<span class="sd">            species: species for which Hubbard-U values are to be loaded.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            device: Device on which to place tensors. [DEFAULT=None]</span>
<span class="sd">            dtype: dtype to be used for floating point tensors. [DEFAULT=None]</span>
<span class="sd">            requires_grad: boolean indicating if gradient tracking should be</span>
<span class="sd">                enabled for the Hubbard-Us. If enabled, the relevant</span>
<span class="sd">                dictionaries and tensors will be converted into `ParameterDict`</span>
<span class="sd">                and `Parameter` instances respectively. [DEFAULT=False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            hubbard_u_feed: A `HubbardFeed` instance containing the</span>
<span class="sd">                Hubbard-U values for the requested species.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import torch</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt import OrbitalInfo</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.physics.dftb.feeds import HubbardFeed</span>
<span class="sd">            &gt;&gt;&gt; from tbmalt.tools.downloaders import download_dftb_parameter_set</span>
<span class="sd">            &gt;&gt;&gt; torch.set_default_dtype(torch.float64)</span>
<span class="sd">            &gt;&gt;&gt; # Download the auorg-1-1 parameter set</span>
<span class="sd">            &gt;&gt;&gt; url = &#39;https://github.com/dftbparams/auorg/releases/download/v1.1.0/auorg-1-1.tar.xz&#39;</span>
<span class="sd">            &gt;&gt;&gt; path = &quot;auorg.h5&quot;</span>
<span class="sd">            &gt;&gt;&gt; download_dftb_parameter_set(url, path)</span>
<span class="sd">            &gt;&gt;&gt; # Definition of feeds</span>
<span class="sd">            &gt;&gt;&gt; u_feed = HubbardFeed.from_database(path, [1, 6])</span>
<span class="sd">            &gt;&gt;&gt; shell_dict = {1: [0], 6: [0, 1]}</span>
<span class="sd">            &gt;&gt;&gt; # Hubbard U values of an example system</span>
<span class="sd">            &gt;&gt;&gt; print(u_feed(OrbitalInfo(torch.tensor([6, 1, 1, 1, 1]), shell_dict)))</span>
<span class="sd">            tensor([0.3647, 0.4196, 0.4196, 0.4196, 0.4196])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">requires_grad</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;requires_grad&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_hubbard_us</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># Read Hubbard-U values for the target species from the associated</span>
            <span class="c1"># Slater-Koster parameter file.</span>
            <span class="n">hubbard_us</span> <span class="o">=</span> <span class="n">Skf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">hubbard_us</span>

            <span class="c1"># `Tensor` -&gt; `Parameter` cast done manually now to give control</span>
            <span class="c1"># over the `requires_grad` option.</span>
            <span class="k">return</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">hubbard_us</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">ParameterDict</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="n">get_hubbard_us</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">species</span><span class="p">}))</span></div>
</div>



<div class="viewcode-block" id="DftbpRepulsiveSpline">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.DftbpRepulsiveSpline.html#tbmalt.physics.dftb.feeds.DftbpRepulsiveSpline">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DftbpRepulsiveSpline</span><span class="p">(</span><span class="n">Feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Repulsive spline representation for the repulsive DFTB interaction.</span>

<span class="sd">    The repulsive spline implementation matches that used by the DFTB+ package.</span>

<span class="sd">    The repulsive potential is partitioned into three regimes and is evaluated</span>
<span class="sd">    only within the specified cutoff radius, being zero beyond this distance.</span>

<span class="sd">    1. **Short-range exponential head** when distances ≤ first grid point:</span>

<span class="sd">       .. math::</span>

<span class="sd">           e^{-a_{1} r + a_{2}} + a_{3}</span>

<span class="sd">    2. **Intermediate cubic spline body** defined on each interval [r_i, r_{i+1}]:</span>

<span class="sd">       .. math::</span>

<span class="sd">           c_{0} + c_{1}(r - r_{0}) + c_{2}(r - r_{0})^{2} + c_{3}(r - r_{0})^{3}</span>

<span class="sd">    3. **Long-range polynomial tail** between the last spline point and cutoff:</span>

<span class="sd">       .. math::</span>

<span class="sd">           c_{0} + c_{1}(r - r_{n}) + c_{2}(r - r_{n})^{2}</span>
<span class="sd">           + c_{3}(r - r_{n})^{3} + c_{4}(r - r_{n})^{4} + c_{5}(r - r_{n})^{5}</span>

<span class="sd">    Arguments:</span>
<span class="sd">        grid: Distances for the primary spline segments including the start &amp;</span>
<span class="sd">            end of the first &amp; last segments respectively. As such there should</span>
<span class="sd">            be n+1 grid points, where n is the number of standard spline</span>
<span class="sd">            segments.</span>
<span class="sd">        cutoff: Cutoff radius for the spline&#39;s tail beyond which interactions</span>
<span class="sd">            are assumed to be zero.</span>
<span class="sd">        spline_coefficients: An n×4 tensor storing the coefficients for each of</span>
<span class="sd">            the primary spline segments.</span>
<span class="sd">        exponential_coefficients: A tensor storing the three coefficients of</span>
<span class="sd">            the short range exponential region.</span>
<span class="sd">        tail_coefficients: A tensor storing the six coefficients of the long -</span>
<span class="sd">            range tail region.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">spline_coefficients</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span>
            <span class="n">exponential_coefficients</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">tail_coefficients</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spline_coefficients</span> <span class="o">=</span> <span class="n">spline_coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exponential_coefficients</span> <span class="o">=</span> <span class="n">exponential_coefficients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail_coefficients</span> <span class="o">=</span> <span class="n">tail_coefficients</span>

        <span class="c1"># Ensure parameters are correctly typed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="ow">or</span> <span class="n">grid</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Setting the grid points as a freely tunable parameter is &quot;</span>
                <span class="s2">&quot;strongly advised against as it may result in unexpected &quot;</span>
                <span class="s2">&quot;behaviour. Please ensure that the `grid` argument is a &quot;</span>
                <span class="s2">&quot;standard `torch.Tensor` type rather than `torch.nn.Parameter` &quot;</span>
                <span class="s2">&quot;and that its </span><span class="se">\&quot;</span><span class="s2">requires_grad</span><span class="se">\&quot;</span><span class="s2"> attribute is set to `False` &quot;</span>
                <span class="s2">&quot;unless you are sure of what you are doing.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="ow">or</span> <span class="n">grid</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The cutoff is not freely tunable parameter. Please ensure &quot;</span>
                <span class="s2">&quot;that the `cutoff` argument is a standard `torch.Tensor` type &quot;</span>
                <span class="s2">&quot;rather than `torch.nn.Parameter` &amp; that its </span><span class="se">\&quot;</span><span class="s2">requires_grad</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="s2">&quot;attribute is set to `False`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spline_coefficients</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The spline coefficients must be a &quot;</span>
                            <span class="s2">&quot;`torch.nn.Parameter` instance.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponential_coefficients</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The exponential coefficients must be a &quot;</span>
                            <span class="s2">&quot;`torch.nn.Parameter` instance.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tail_coefficients</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The tail coefficients must be a &quot;</span>
                            <span class="s2">&quot;`torch.nn.Parameter` instance.&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure that the tensors are of the correct shape</span>
        <span class="k">if</span> <span class="n">spline_coefficients</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">spline_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument `spline_coefficients` should be an n×4 &quot;</span>
                             <span class="s2">&quot;tensor.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">spline_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> grid values were provided suggesting the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;presence of </span><span class="si">{</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> standard spline segments. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;However, coefficients for </span><span class="si">{</span><span class="n">spline_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;segments were provided in `spline_coefficients`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exponential_coefficients</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected `exponential_coefficients` argument to be of shape &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;torch.Size([3]) but encountered &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">exponential_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tail_coefficients</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">6</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected `tail_coefficients` argument to be of shape &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;torch.Size([6]) but encountered </span><span class="si">{</span><span class="n">tail_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spline_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cutoff distance of the last primary spline segment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">exponential_cutoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cutoff distance of the short range exponential region.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="DftbpRepulsiveSpline.forward">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.DftbpRepulsiveSpline.html#tbmalt.physics.dftb.feeds.DftbpRepulsiveSpline.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the repulsive interaction at the specified distance(s).</span>

<span class="sd">        Arguments:</span>
<span class="sd">            distances: Distance(s) at which the repulsive term is to be</span>
<span class="sd">                evaluated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            repulsive: Repulsive interaction energy as evaluated at the</span>
<span class="sd">                specified distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

        <span class="c1"># Mask for distances &lt; cutoff</span>
        <span class="n">under_cutoff</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>

        <span class="c1"># Within that subset, distinguish three further conditions:</span>
        <span class="c1"># 1) distances &gt; spline_cutoff</span>
        <span class="n">mask_1</span> <span class="o">=</span> <span class="n">under_cutoff</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">distances</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_cutoff</span><span class="p">)</span>
        <span class="c1"># 2) distances &gt; exponential_cutoff and &lt;= spline_cutoff</span>
        <span class="n">mask_2</span> <span class="o">=</span> <span class="n">under_cutoff</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">distances</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponential_cutoff</span>
                                 <span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">distances</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_cutoff</span><span class="p">)</span>
        <span class="c1"># 3) distances &lt;= exp_cutoff</span>
        <span class="n">mask_3</span> <span class="o">=</span> <span class="n">under_cutoff</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">distances</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponential_cutoff</span><span class="p">)</span>

        <span class="c1"># Evaluate the distances in each of the three main distance regimes</span>
        <span class="c1"># accordingly.</span>
        <span class="n">results</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">mask_1</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">mask_2</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="n">mask_3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exponential</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">mask_3</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">results</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_exponential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the exponential head of the repulsive interaction.</span>

<span class="sd">        The short-range exponential part of the repulsive interaction is</span>
<span class="sd">        applied when the atoms are closer than the starting distance of the</span>
<span class="sd">        first standard spline segment. The repulsive interaction within this</span>
<span class="sd">        region is described by the following exponential term:</span>

<span class="sd">        .. math::</span>

<span class="sd">            e^{-a_{1} r + a_{2}} + a_{3}</span>

<span class="sd">        Where &quot;r&quot; (`distances`) is the distance between the atoms and</span>
<span class="sd">        :math:`a_{i}` are the exponential coefficients.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            distance: Distance(s) at which the exponential term is to be</span>
<span class="sd">                evaluated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            repulsive: Exponential repulsive interaction as evaluated at the</span>
<span class="sd">                specified distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponential_coefficients</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate main spline body of the repulsive interaction.</span>

<span class="sd">        Distances between the exponential head and fifth order polynomial</span>
<span class="sd">        spline tail are evaluated using a third order polynomial spline of</span>
<span class="sd">        the form:</span>

<span class="sd">        .. math::</span>

<span class="sd">            c_{0}+c_{1}(r-r_{0})+c_{2}(r-r_{0})^{2}+c_{3}(r-r_{0})^{3}</span>

<span class="sd">        Where &quot;r&quot; (`distances`) is the distance between the atoms,</span>
<span class="sd">        :math:`r_{0}` is the start of the spline segment, and :math:`c_{i}` are</span>
<span class="sd">        the spline segment&#39;s coefficients.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            distance: Distance(s) at which the primary spline term is to be</span>
<span class="sd">                evaluated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            repulsive: Primary spline body repulsive interaction as evaluated</span>
<span class="sd">                at the specified distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_coefficients</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="n">c</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">3</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the polynomial tail part of the repulsive interaction.</span>

<span class="sd">        Distance between the last standard spline segment&#39;s endpoint and the</span>
<span class="sd">        cutoff are represented by a tail spline of the form:</span>

<span class="sd">        .. math::</span>

<span class="sd">            c_{0}+c_{1}(r-r_{0})+c_{2}(r-r_{0})^{2}+c_{3}(r-r_{0})^{3}</span>
<span class="sd">                +c_{4}(r-r_{0})^{4}+c_{5}(r-r_{0})^{5}</span>

<span class="sd">        Where &quot;r&quot; (`distances`) is the distance between the atoms,</span>
<span class="sd">        :math:`r_{0}` is the start of the tail region, and :math:`c_{i}` are</span>
<span class="sd">        the tail spline&#39;s coefficients.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            distance: Distance(s) at which the long-range spline tail term is</span>
<span class="sd">                to be evaluated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            repulsive: Spline tail repulsive interaction as evaluated at the</span>
<span class="sd">                specified distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail_coefficients</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_cutoff</span>
        <span class="n">r_poly</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">r_poly</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="DftbpRepulsiveSpline.from_skf">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.DftbpRepulsiveSpline.html#tbmalt.physics.dftb.feeds.DftbpRepulsiveSpline.from_skf">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_skf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">skf</span><span class="p">:</span> <span class="n">Skf</span><span class="p">,</span> <span class="n">requires_grad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DftbpRepulsiveSpline</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate a `DftbpRepulsiveSpline` instance from a `Skf` object.</span>

<span class="sd">        This method will read the repulsive spline data from an `Skf` instance</span>
<span class="sd">        representing an sfk formatted file and construct a repulsive spline</span>
<span class="sd">        of the form used by the DFTB+ package.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            skf: An `Skf` instance representing an skf file from which the</span>
<span class="sd">                data parameterising the repulsive spline can be read.</span>
<span class="sd">            requires_grad: A boolean indicating if the gradient tracking should</span>
<span class="sd">                be enabled for the spline&#39;s coefficients. [DEFAULT=False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            repulsive_feed: A `DftbpRepulsiveSpline` instance representing the</span>
<span class="sd">                repulsive interaction.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This assumes the presence of repulsive spline feed in the skf file.</span>
<span class="sd">            However, this condition is not guaranteed as some skf files will</span>
<span class="sd">            provide a polynomial instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skf</span><span class="o">.</span><span class="n">r_spline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Skf file </span><span class="si">{</span><span class="n">skf</span><span class="si">}</span><span class="s2"> does not define a repulsive spline.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_r_spline</span><span class="p">(</span><span class="n">skf</span><span class="o">.</span><span class="n">r_spline</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">)</span></div>


<div class="viewcode-block" id="DftbpRepulsiveSpline.from_r_spline">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.DftbpRepulsiveSpline.html#tbmalt.physics.dftb.feeds.DftbpRepulsiveSpline.from_r_spline">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_r_spline</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">r_spline</span><span class="p">:</span> <span class="n">Skf</span><span class="o">.</span><span class="n">RSpline</span><span class="p">,</span> <span class="n">requires_grad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DftbpRepulsiveSpline</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate a `DftbpRepulsiveSpline` instance from a `Skf.RSpline` object.</span>

<span class="sd">        This method will use an `Skf.RSpline` data class to construct a</span>
<span class="sd">        repulsive spline of the form used by the DFTB+ package.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            skf: An `Skf.RSpline` instance parameterising the repulsive spline.</span>
<span class="sd">            requires_grad: A boolean indicating if the gradient tracking should</span>
<span class="sd">                be enabled for the spline&#39;s coefficients. [DEFAULT=False]</span>

<span class="sd">        Returns:</span>
<span class="sd">            repulsive_feed: A `DftbpRepulsiveSpline` instance representing the</span>
<span class="sd">                repulsive interaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">r_spline</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">r_spline</span><span class="o">.</span><span class="n">cutoff</span><span class="p">,</span>
            <span class="n">Parameter</span><span class="p">(</span><span class="n">r_spline</span><span class="o">.</span><span class="n">spline_coef</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">),</span>
            <span class="n">Parameter</span><span class="p">(</span><span class="n">r_spline</span><span class="o">.</span><span class="n">exp_coef</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">),</span>
            <span class="n">Parameter</span><span class="p">(</span><span class="n">r_spline</span><span class="o">.</span><span class="n">tail_coef</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="PairwiseRepulsiveEnergyFeed">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.PairwiseRepulsiveEnergyFeed.html#tbmalt.physics.dftb.feeds.PairwiseRepulsiveEnergyFeed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PairwiseRepulsiveEnergyFeed</span><span class="p">(</span><span class="n">Feed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sort range repulsive interaction feed for DFTB calculations.</span>

<span class="sd">    This feed uses distance dependent interpolator feeds to evaluate the</span>
<span class="sd">    total repulsive pair-wise interaction energy for a given system.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        repulsive_feeds: A torch `ModuleDict` of pair-wise distance dependent</span>
<span class="sd">            repulsive feeds, such as `DftbpRepulsiveSpline`, keyed by strings</span>
<span class="sd">            representing tuples of the form `&quot;(z₁, z₂)&quot;`, where `z₁` &amp; `z₂` are</span>
<span class="sd">            the atomic numbers of the associated element pair (with `z₁ ≤ z₂`).</span>
<span class="sd">            Keys must exactly match the string obtained from converting a tuple</span>
<span class="sd">            to a string, including the parentheses &amp; spaces; for example,</span>
<span class="sd">            `&quot;(1, 6)&quot;`.</span>

<span class="sd">    Notes:</span>
<span class="sd">        In principle any feed may be placed within the ``repulsive_feeds``</span>
<span class="sd">        dictionary to represent repulsive interactions so long as its `forward`</span>
<span class="sd">        method takes a distances values and returns repulsive energy values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repulsive_feeds</span><span class="p">:</span> <span class="n">ModuleDict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Feed</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">repulsive_feeds</span> <span class="o">=</span> <span class="n">repulsive_feeds</span>

        <span class="c1"># Ensure that the repulsive feeds are stored within a ModuleDict</span>
        <span class="c1"># instance, rather than something else like a standard Python</span>
        <span class="c1"># dictionary.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">repulsive_feeds</span><span class="p">,</span> <span class="n">ModuleDict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;An instance of `torch.nn.ModuleDict` was expected for the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;attribute `repulsive_feeds`, but a `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">repulsive_feeds</span><span class="p">)</span><span class="si">}</span><span class="s2">` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;was encountered.&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure the keys used in the repulsive feed module dictionary</span>
        <span class="c1"># match the expected form.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">repulsive_feeds</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__validate_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<div class="viewcode-block" id="PairwiseRepulsiveEnergyFeed.forward">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.PairwiseRepulsiveEnergyFeed.html#tbmalt.physics.dftb.feeds.PairwiseRepulsiveEnergyFeed.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Repulsive energy.</span>

<span class="sd">        Compute the pair-wise repulsive energy of the specified system using</span>
<span class="sd">        the element pair specific pair-wise repulsive sub-feeds.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            geometry: System, or batch thereof, for which the repulsive</span>
<span class="sd">                interaction energy is to be computed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            repulsive: Repulsive interaction energy as evaluated for the</span>
<span class="sd">                specified system(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Tensor to hold the resulting repulsive energy.</span>
        <span class="n">e_rep</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">geometry</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">device</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># For each species pair, atom indices and distances are yielded with a</span>
        <span class="c1"># forced batch dimension, facilitating batch-agnostic scatter addition.</span>
        <span class="k">for</span> <span class="n">species_pair</span><span class="p">,</span> <span class="n">atomic_indices</span><span class="p">,</span> <span class="n">distances</span> <span class="ow">in</span> <span class="n">atomic_pair_distances</span><span class="p">(</span>
                <span class="n">geometry</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="c1"># Identify the repulsive feed associated with the current pair</span>
            <span class="n">feed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repulsive_feeds</span><span class="p">[</span>
                <span class="nb">str</span><span class="p">((</span><span class="n">species_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">species_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))]</span>

            <span class="c1"># evaluate it at the relevant distances</span>
            <span class="n">e_pairs</span> <span class="o">=</span> <span class="n">feed</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

            <span class="c1"># add the resulting energies to the current total(s)</span>
            <span class="n">e_rep</span><span class="o">.</span><span class="n">scatter_add_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">atomic_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e_pairs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">e_rep</span></div>


<div class="viewcode-block" id="PairwiseRepulsiveEnergyFeed.from_database">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.feeds.PairwiseRepulsiveEnergyFeed.html#tbmalt.physics.dftb.feeds.PairwiseRepulsiveEnergyFeed.from_database">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_database</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">requires_grad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate instance from an HDF5 database of Slater-Koster files.</span>

<span class="sd">        Instantiate a `PairwiseRepulsiveEnergyFeed` instance for the specified</span>
<span class="sd">        elements using repulsive data contained within a Slater-Koster HDF5</span>
<span class="sd">        file. More specifically, the repulsive spline coefficients will be</span>
<span class="sd">        parsed and used to construct a series of `DftbpRepulsiveSpline`</span>
<span class="sd">        instances.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            path: Path to the HDF5 file from which repulsive splines data</span>
<span class="sd">                should be sourced.</span>
<span class="sd">            species: Species for which repulsive interactions should be</span>
<span class="sd">                loaded.</span>
<span class="sd">            requires_grad: When set to `True` gradient tracking will be enabled</span>
<span class="sd">                for all coefficients within the repulsive spline feeds.</span>
<span class="sd">                [DEFAULT=False]</span>
<span class="sd">            device: Device on which the feed object and its contents resides.</span>
<span class="sd">            dtype: dtype used by feed object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            repulsive_energy_feed: An `PairwiseRepulsiveEnergyFeed` instance</span>
<span class="sd">                with the required repulsive interactions represented using</span>
<span class="sd">                `DftbpRepulsiveSpline` instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">repulsive_feeds</span> <span class="o">=</span> <span class="n">ModuleDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">species</span><span class="p">),</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">skf</span> <span class="o">=</span> <span class="n">Skf</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">repulsive_feeds</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">pair</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DftbpRepulsiveSpline</span><span class="o">.</span><span class="n">from_skf</span><span class="p">(</span>
                <span class="n">skf</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="n">requires_grad</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">repulsive_feeds</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__validate_key</span><span class="p">(</span><span class="n">key_string</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate format of an element pair module-dictionary key.</span>

<span class="sd">        Validates that the provided string matches the expected format of a tuple</span>
<span class="sd">        converted to a string, i.e., &quot;(z₁, z₂)&quot;.</span>

<span class="sd">        The string must:</span>
<span class="sd">        - Start with a left parenthesis &#39;(&#39;</span>
<span class="sd">        - End with a right parenthesis &#39;)&#39;</span>
<span class="sd">        - Contain exactly two comma-separated integers</span>
<span class="sd">        - Have exactly one space after each comma</span>
<span class="sd">        - Ensure that z₁ ≤ z₂</span>

<span class="sd">        Arguments:</span>
<span class="sd">            key_string: The string to validate.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If any of the validation checks fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Check if the string starts with &#39;(&#39; and ends with &#39;)&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">key_string</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key_string</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)):</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;The string must start with &#39;(&#39; and end with &#39;)&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remove the parentheses</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">key_string</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Define the expected pattern</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^(\d+), (\d+)$&#39;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;The string must contain exactly two comma-separated integers, &quot;</span>
                    <span class="s2">&quot;with exactly one space after each comma.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>

                <span class="c1"># Check if z₁ ≤ z₂</span>
                <span class="k">if</span> <span class="n">z1</span> <span class="o">&gt;</span> <span class="n">z2</span><span class="p">:</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;The first atomic number z₁ must be less than or equal to &quot;</span>
                        <span class="s2">&quot;the second atomic number z₂.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;The string </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">key_string</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2"> used as a key in the&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`repulsive_feeds` dictionary does not match the expected &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;format. It should represent a tuple converted to a string, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;like &#39;(1, 6)&#39;.&quot;</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, TBMaLT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>