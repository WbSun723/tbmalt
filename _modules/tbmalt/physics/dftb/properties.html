

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tbmalt.physics.dftb.properties &mdash; TBMaLT 0.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=7026087e"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            TBMaLT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">1. Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html">2. Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">3. Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../development.html">4. Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide.html">5. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release_notes.html">6. Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">TBMaLT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../dftb.html">tbmalt.physics.dftb</a></li>
      <li class="breadcrumb-item active">tbmalt.physics.dftb.properties</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tbmalt.physics.dftb.properties</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Functions relating to the calculation of physical properties.</span>

<span class="sd">This module contains functions pertaining to the calculation of general</span>
<span class="sd">properties.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Real</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">pack</span><span class="p">,</span> <span class="n">bT</span>

<span class="n">Tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>


<span class="c1">##################################</span>
<span class="c1"># Density of States Related Code #</span>
<span class="c1">##################################</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_generate_broadening</span><span class="p">(</span><span class="n">energies</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
                         <span class="n">sigma</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Real</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct the gaussian broadening terms.</span>

<span class="sd">    This is used to calculate the gaussian broadening terms used when</span>
<span class="sd">    calculating the DoS/PDoS.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        energies: Energy values to evaluate the DoS/PDoS at.</span>
<span class="sd">        eps: Energy eigenvalues (epsilon).</span>
<span class="sd">        sigma: Smearing width for gaussian broadening function. [DEFAULT=0]</span>

<span class="sd">    Returns:</span>
<span class="sd">        g: Gaussian broadening terms.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_gaussian_broadening</span><span class="p">(</span><span class="n">energy_in</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">eps_in</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">Real</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gaussian broadening factor used when calculating the DoS/PDoS.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bT</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">bT</span><span class="p">(</span><span class="n">energy_in</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">eps_in</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
                         <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)))</span>

    <span class="c1"># Construct gaussian smearing terms.</span>
    <span class="n">de</span> <span class="o">=</span> <span class="n">energies</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">energies</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ga</span> <span class="o">=</span> <span class="n">_gaussian_broadening</span><span class="p">(</span><span class="n">bT</span><span class="p">(</span><span class="n">bT</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">de</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">eps</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">gb</span> <span class="o">=</span> <span class="n">_gaussian_broadening</span><span class="p">(</span><span class="n">bT</span><span class="p">(</span><span class="n">bT</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">de</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">eps</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bT</span><span class="p">(</span><span class="n">bT</span><span class="p">(</span><span class="n">gb</span> <span class="o">-</span> <span class="n">ga</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">de</span><span class="p">))</span>


<div class="viewcode-block" id="dos">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.properties.dos.html#tbmalt.physics.dftb.properties.dos">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dos</span><span class="p">(</span><span class="n">eps</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">energies</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Real</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Real</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the density of states for one or more systems.</span>

<span class="sd">    This calculates and returns the Density of States (DoS) for one or more</span>
<span class="sd">    systems. If desired, all but a selection of specific states can be masked</span>
<span class="sd">    out via the ``mask`` argument.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        eps: Energy eigenvalues (epsilon).</span>
<span class="sd">        energies: Energy values to evaluate the DoS at. These are assumed to</span>
<span class="sd">            be relative to the ``offset`` value, if it is specified.</span>
<span class="sd">        sigma: Smearing width for gaussian broadening function. [DEFAULT=0]</span>
<span class="sd">        offset: Indicates that ``energies`` are given with respect to a offset</span>
<span class="sd">            value, e.g. the fermi energy.</span>
<span class="sd">        mask: Used to control which states are used in constricting the DoS.</span>
<span class="sd">            Only unmasked (True) states will be used, all others are ignored.</span>
<span class="sd">        scale: Scales the DoS to have a maximum value of 1. [DEFAULT=False]</span>

<span class="sd">    Returns:</span>
<span class="sd">        dos: The densities of states.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The DoS is calculated via an equation equivalent to:</span>

<span class="sd">        .. math::</span>
<span class="sd">            g(E)=\delta(E-\epsilon_{i})</span>

<span class="sd">        Where g(E) is the density of states at an energy value E, and δ(E-ε)</span>
<span class="sd">        is the smearing width calculated as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \delta(E-\epsilon)=\frac{</span>
<span class="sd">                erf\left(\frac{E-\epsilon+\frac{\Delta E}{2}}{\sqrt{2}\sigma}\right)-</span>
<span class="sd">                erf\left(\frac{E-\epsilon-\frac{\Delta E}{2}}{\sqrt{2}\sigma}\right)}</span>
<span class="sd">                {2\Delta E}</span>

<span class="sd">        Where ΔE is the difference in energy between neighbouring points.</span>
<span class="sd">        It may be useful, such as in the creation of a cost function, to have</span>
<span class="sd">        only specific states (i.e. HOMO, HOMO-1, etc.) used to construct the</span>
<span class="sd">        PDoS. State selection can be achieved via the ``mask`` argument. This</span>
<span class="sd">        should be a boolean tensor with a shape matching that of ``eps``. Only</span>
<span class="sd">        states whose mask value is True will be included in the DoS, e.g.</span>

<span class="sd">            mask = torch.Tensor([True, False, False, False])</span>

<span class="sd">        would only use the first state when constructing the DoS.</span>

<span class="sd">    Warnings:</span>
<span class="sd">        It is imperative that padding values are masked out when operating on</span>
<span class="sd">        batches of systems! Failing to do so will result in the emergence of</span>
<span class="sd">        erroneous state occupancies. Care must also be taken to ensure that</span>
<span class="sd">        the number of sample points is the same for each system; i.e. all</span>
<span class="sd">        systems have the same number of elements in ``energies``. As padding</span>
<span class="sd">        values will result in spurious behaviour.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Density of states constructed for an H2 molecule using test data:</span>

<span class="sd">        &gt;&gt;&gt; from tests.unittests.data.properties.dos import H2</span>
<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb.properties import dos</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; eps = H2[&#39;eigenvalues&#39;]</span>
<span class="sd">        &gt;&gt;&gt; energies = H2[&#39;dos&#39;][&#39;energy&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sigma = H2[&#39;sigma&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dos_values = dos(eps, energies, sigma)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(energies, dos_values)</span>
<span class="sd">        &gt;&gt;&gt; plt.xlabel(&#39;Energy [Ha]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;DoS [Ha]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Mask out selected eigen-states if requested.</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>  <span class="c1"># Use a clone to prevent altering the original</span>
        <span class="c1"># Move masked states towards +inf</span>
        <span class="n">eps</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">eps</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>

    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Apply the offset, if applicable.</span>
        <span class="c1"># Offset must be applied differently for batches.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">-</span> <span class="n">offset</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">-</span> <span class="n">offset</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">_generate_broadening</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>  <span class="c1"># Gaussian smearing terms.</span>
    <span class="n">distribution</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Compute the densities of states</span>

    <span class="c1"># Rescale the DoS so that it has a maximum peak value of 1.</span>
    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="n">distribution</span> <span class="o">=</span> <span class="n">distribution</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">distribution</span></div>



<div class="viewcode-block" id="band_pass_state_filter">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.physics.dftb.properties.band_pass_state_filter.html#tbmalt.physics.dftb.properties.band_pass_state_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">band_pass_state_filter</span><span class="p">(</span><span class="n">eps</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">n_homo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
                           <span class="n">n_lumo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
                           <span class="n">fermi</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Real</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates masks able to filter out states too far from the fermi level.</span>

<span class="sd">     This function returns a mask for each ``eps`` system that can filter out</span>
<span class="sd">     all but a select number of states above and below the fermi level.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        eps: Eigenvalues.</span>
<span class="sd">        n_homo: n states below the fermi level to retain, including the HOMO.</span>
<span class="sd">        n_lumo: n states above the fermi level to retain.</span>
<span class="sd">        fermi: Fermi level.</span>

<span class="sd">    Returns:</span>
<span class="sd">        mask: A boolean mask which is True for selected states.</span>

<span class="sd">    Notes:</span>
<span class="sd">        For each system, a ``n_homo``, ``n_lumo``, and ``fermi`` value must be</span>
<span class="sd">        provided. This assumes that all states, ``eps`` are ordered from</span>
<span class="sd">        lowest to highest.</span>

<span class="sd">    Warnings:</span>
<span class="sd">        It is down to the user to ensure that the number of requested HOMOs &amp;</span>
<span class="sd">        LUMOs for each system is valid. This cannot be done safely here due to</span>
<span class="sd">        the effects of zero-padded packing; i.e. this function sees padding</span>
<span class="sd">        zeros as valid LUMO states.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If multiple systems have been provided but not multiple</span>
<span class="sd">            ``n_homo``, ``n_lumo``, and ``fermi`` values.</span>

<span class="sd">    Examples:</span>
<span class="sd">        Here, all but three states below and two states above the fermi level</span>
<span class="sd">        are masked out:</span>

<span class="sd">        &gt;&gt;&gt; from tbmalt.physics.dftb.properties import band_pass_state_filter</span>
<span class="sd">        &gt;&gt;&gt; eps = torch.arange(-4., 6.)</span>
<span class="sd">        &gt;&gt;&gt; mask = band_pass_state_filter(eps, 3, 2, 0.)</span>
<span class="sd">        &gt;&gt;&gt; print(eps)</span>
<span class="sd">        tensor([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.,  5.])</span>
<span class="sd">        &gt;&gt;&gt; print(mask)</span>
<span class="sd">        tensor([False, False, True,  True,  True,  True,  True,  False,</span>
<span class="sd">                False, False])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">index_list</span><span class="p">(</span><span class="n">eps_in</span><span class="p">,</span> <span class="n">fermi_in</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a state index list offset relative to the HOMO level.</span>

<span class="sd">        e.g: [-n, ..., -2, -1, 0, 1, 2, ..., +n], where 0 is at the index of</span>
<span class="sd">        the HOMO. An issue is encountered when operating on zero-padded packed</span>
<span class="sd">        data, as the padding 0s can get miss-identified as the homo. We want:</span>
<span class="sd">        [True, True, True, False, False, True, True]</span>
<span class="sd">                 this ↑,   but not these: ↑     ↑, to be the zero point. Thus,</span>
<span class="sd">        a more involved method must be used to get the HOMO state&#39;s index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">le_fermi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">eps_in</span> <span class="o">&lt;=</span> <span class="n">fermi_in</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Find values ≤ fermi</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">le_fermi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If there&#39;s 1 value; then it is homo e.g. H2.</span>
            <span class="n">homo</span> <span class="o">=</span> <span class="n">le_fermi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Construct a difference array to highlight non-sequential states.</span>
            <span class="c1"># The Homo will be the last entry of the first sequential block.</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">le_fermi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">le_fermi</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">homo</span> <span class="o">=</span> <span class="n">le_fermi</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">unique_consecutive</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>


        <span class="c1"># Generate and return the index list</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">eps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">eps</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-</span> <span class="n">homo</span>

    <span class="c1"># If multiple systems were specified then ensure that multiple n_homo,</span>
    <span class="c1"># n_lumo, and fermi values were also specified.</span>
    <span class="k">if</span> <span class="n">eps</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                    <span class="p">[</span><span class="n">n_homo</span><span class="p">,</span> <span class="n">n_lumo</span><span class="p">,</span> <span class="n">fermi</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;n_homo, n_lumo, and fermi values must be &#39;</span>
                               <span class="s1">&#39;provided for each system.&#39;</span><span class="p">)</span>

    <span class="c1"># Build relative index list, batch &amp; non-batch must be handled differently.</span>
    <span class="k">if</span> <span class="n">eps</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ril</span> <span class="o">=</span> <span class="n">index_list</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="n">fermi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ril</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">index_list</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="n">fermi</span><span class="p">)])</span>

    <span class="c1"># Create &amp; return a mash that masks out states outside of the band filter</span>
    <span class="k">return</span> <span class="n">bT</span><span class="p">((</span><span class="o">-</span><span class="n">n_homo</span> <span class="o">&lt;</span> <span class="n">bT</span><span class="p">(</span><span class="n">ril</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bT</span><span class="p">(</span><span class="n">ril</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n_lumo</span><span class="p">))</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, TBMaLT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>