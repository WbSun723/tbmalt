

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tbmalt.ml.integralfeeds &mdash; TBMaLT 0.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=7026087e"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            TBMaLT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">1. Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">2. Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">3. Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development.html">4. Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide.html">5. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">6. Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">TBMaLT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../ml.html">tbmalt.ml</a></li>
      <li class="breadcrumb-item active">tbmalt.ml.integralfeeds</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tbmalt.ml.integralfeeds</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Electronic integral feed objects.</span>

<span class="sd">This contains all the electronic integral feed objects. These objects are</span>
<span class="sd">responsible for generating the Hamiltonian and overlap matrices. The on-site</span>
<span class="sd">and off-site blocks are constructed by the `on_site_blocks` &amp; `off_site_blocks`</span>
<span class="sd">class methods respectively.</span>

<span class="sd">Warning:</span>
<span class="sd">     This is development stage code and is subject to significant change.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">h5py</span><span class="w"> </span><span class="kn">import</span> <span class="n">Group</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">ndarray</span> <span class="k">as</span> <span class="n">Array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">OrbitalInfo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.structures.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">atomic_pair_indices</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.ml</span><span class="w"> </span><span class="kn">import</span> <span class="n">Feed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.ml.calculator</span><span class="w"> </span><span class="kn">import</span> <span class="n">Calculator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tbmalt.common.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">bT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>


<div class="viewcode-block" id="indices">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.indices.html#tbmalt.ml.integralfeeds.indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">indices</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pytorch implementation of numpy.indices</span>

<span class="sd">    Note this is a temporary function which will be abstracted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">long</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_dims</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),)</span> <span class="o">+</span> <span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n_dims</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
            <span class="n">sp</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span><span class="p">,)</span> <span class="o">+</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span></div>



<div class="viewcode-block" id="IntegralFeed">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IntegralFeed</span><span class="p">(</span><span class="n">Feed</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;ABC for Hamiltonian and overlap matrix constructors.</span>

<span class="sd">    Subclasses of this abstract base class are responsible for constructing</span>
<span class="sd">    the Hamiltonian and overlap matrices.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        device: Device on which the feed object and its contents resides.</span>
<span class="sd">        dtype: Floating point dtype used by feed object.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># These variables must NEVER be modified outside the .to method!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialises subclass structures.</span>

<span class="sd">        When a new subclass is initialised this will decorate various methods</span>
<span class="sd">        with a selection of wrapper functions. These wrappers will automate</span>
<span class="sd">        some of the more repetitive error handling operations needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The device on which the feed object resides.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__device</span>

    <span class="nd">@device</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># Instruct users to use the &quot;.to&quot; method if wanting to change device.</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> object</span><span class="se">\&#39;</span><span class="s1">s dtype can only be modified &#39;</span>
                             <span class="s1">&#39;via the &quot;.to&quot; method.&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Floating point dtype used by feed object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dtype</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__enforce_orbital_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper function to ensure orbital consistency.</span>

<span class="sd">        This ensures that all the requested sub-blocks are of the same shape</span>
<span class="sd">        during calls to the ``off_site_blocks`` &amp; ``on_site_blocks`` methods.</span>
<span class="sd">        Issues will be encountered if different sized sub-blocks are requested</span>
<span class="sd">        during a single call; this wrapper just ensures a helpful exception is</span>
<span class="sd">        provided to the user.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="IntegralFeed.partition_blocks">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed.partition_blocks">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">partition_blocks</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask identifying on-site interaction pairs.</span>

<span class="sd">        This helper function constructs a mask which is True wherever the</span>
<span class="sd">        associated atom index pair corresponds to an on-site interaction.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            atomic_idx_1: Atomic indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            atomic_idx_2: Atomic indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                desired interaction block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            on_site_mask: A tensor that is truthy wherever the atom index</span>
<span class="sd">                pair corresponds to an on-site interaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">on_site_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">on_site_mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">on_site_mask</span> <span class="o">=</span> <span class="n">on_site_mask</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">on_site_mask</span></div>


<div class="viewcode-block" id="IntegralFeed.blocks">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed.blocks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
               <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute atomic interaction blocks.</span>

<span class="sd">        Returns the atomic blocks associated with the atoms in ``atomic_idx_1``</span>
<span class="sd">        interacting with those in ``atomic_idx_2``. The № of interaction blocks</span>
<span class="sd">        returned will be equal to the length of the two index lists; i.e. *not*</span>
<span class="sd">        one for every combination.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            atomic_idx_1: Atomic indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            atomic_idx_2: Atomic indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            geometry: The systems to which the atomic indices relate.</span>
<span class="sd">            orbs: Orbital information associated with said systems.</span>

<span class="sd">        Returns:</span>
<span class="sd">            blocks: Requested atomic interaction sub-blocks.</span>

<span class="sd">        Warnings:</span>
<span class="sd">            All requested blocks must have the same shape &amp; size.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If both indices of an index pair refer to the same atom then the</span>
<span class="sd">            block will represent an on-site interaction, otherwise it will be</span>
<span class="sd">            an off-site interaction.</span>

<span class="sd">            The index tensor has been split in two; while this increases</span>
<span class="sd">            verbosity it decreases the complexity needed to ensure batch</span>
<span class="sd">            agnosticism.</span>

<span class="sd">            If operating on a batch of systems; index tensors will be 2xN where</span>
<span class="sd">            the 1&#39;st &amp; 2&#39;nd rows specify the batch &amp; atom indices respectively.</span>
<span class="sd">            Otherwise, they will be one dimensional tensors of length N where N</span>
<span class="sd">            is the number of interactions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Developers Notes</span>
        <span class="c1"># This method is mostly called from ``matrix``; which loops over all</span>
        <span class="c1"># species combinations, H-C, H-C, C-C, ..., etc. &amp; request all of the</span>
        <span class="c1"># interaction blocks associated with that species pair.</span>
        <span class="c1">#</span>
        <span class="c1"># The index arrays can be used to retrieve information, such as</span>
        <span class="c1"># positions, like so ``geometry.positions[atomic_idx_1.T]``.</span>
        <span class="c1">#</span>
        <span class="c1"># The ``partition_blocks`` helper method makes splitting interactions</span>
        <span class="c1"># into off- and on-site blocks easier when necessary.</span>
        <span class="c1">#</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="IntegralFeed.matrix">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed.matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct the hermitian matrix associated with this feed.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            geometry: Systems whose matrices are to be constructed.</span>
<span class="sd">            orbs: Orbital information associated with said systems.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            kwargs: Any keyword arguments provided are passed during calls to</span>
<span class="sd">                the `blocks` method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matrix: The resulting matrices.</span>

<span class="sd">        Warnings:</span>
<span class="sd">            This method is in rapid development and is thus subject to change</span>
<span class="sd">            and or abstraction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Developers Notes</span>
        <span class="c1"># There is still quite a bit left to do in this function; even when one</span>
        <span class="c1"># discounts optimisation, cleaning, and improving batch agnosticism.</span>

        <span class="c1"># Construct the matrix into which the results will be placed</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">orbs</span><span class="o">.</span><span class="n">orbital_matrix_shape</span><span class="p">,</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Loop over pairwise interactions by species type</span>
        <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">a_idx</span> <span class="ow">in</span> <span class="n">atomic_pair_indices</span><span class="p">(</span>
                <span class="n">geometry</span><span class="p">,</span> <span class="n">ignore_periodicity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">a_idx</span> <span class="o">=</span> <span class="n">a_idx</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Reshape atom index list to be more amenable to advanced indexing.</span>
            <span class="n">a_idx_l</span> <span class="o">=</span> <span class="n">a_idx</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">b_idx_l</span> <span class="o">=</span> <span class="n">a_idx</span><span class="p">[:,</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">a_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Get the matrix indices associated with the target blocks.</span>
            <span class="n">blk_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_block_indices</span><span class="p">(</span><span class="n">a_idx_l</span><span class="p">,</span> <span class="n">b_idx_l</span><span class="p">,</span> <span class="n">orbs</span><span class="p">)</span>

            <span class="c1"># Construct the blocks for these interactions</span>
            <span class="n">blks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">(</span><span class="n">a_idx_l</span><span class="p">,</span> <span class="n">b_idx_l</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Assign data to the matrix. As on-site blocks are not masked out</span>
            <span class="c1"># during the transpose assignment the transpose assignment must</span>
            <span class="c1"># be done first (this is only matters for complex diagonal blocks).</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[</span><span class="o">*</span><span class="n">blk_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">blks</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="n">mat</span><span class="p">[</span><span class="o">*</span><span class="n">blk_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">blks</span>

        <span class="k">return</span> <span class="n">mat</span></div>


<div class="viewcode-block" id="IntegralFeed.matrix_from_calculator">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed.matrix_from_calculator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">matrix_from_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculator</span><span class="p">:</span> <span class="n">Calculator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct the hermitian matrix associated with this feed.</span>

<span class="sd">        This method extracts the required arguments from the supplied</span>
<span class="sd">        ``calculator`` argument &amp; redirects to the `matrix` method. This allows</span>
<span class="sd">        for a `Calculator` to call a feeds `matrix` method in a call signature</span>
<span class="sd">        agnostic manner.</span>

<span class="sd">        Args:</span>
<span class="sd">            calculator: a calculator object from which the necessary data can</span>
<span class="sd">                be extracted.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            kwargs: Any keyword arguments provided are passed during calls to</span>
<span class="sd">                the `blocks` method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matrix: The resulting matrices.</span>

<span class="sd">        Notes:</span>
<span class="sd">                Each `IntegralFeed` object&#39;s `matrix` method may require any</span>
<span class="sd">                number of arbitrary arguments. Consequently, it is unreasonable</span>
<span class="sd">                to expect a `Calculator` instance to know how to correctly</span>
<span class="sd">                invoke the `matrix` method for any given feed, particularly</span>
<span class="sd">                without resorting to introspection and reflection, which would</span>
<span class="sd">                introduce an unnecessary degree of complexity. Therefore, this</span>
<span class="sd">                pseudo-overload method is established, enabling `Calculator`s</span>
<span class="sd">                to simply pass themselves in as the sole argument. This</span>
<span class="sd">                approach allows the feed to extract the necessary data</span>
<span class="sd">                independently and make the call to `matrix` itself. While this</span>
<span class="sd">                is potentially more prone to errors, the errors that may arise</span>
<span class="sd">                are expected to be clearer and easier to resolve, thus</span>
<span class="sd">                enhancing the overall maintainability and debuggability.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">calculator</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">calculator</span><span class="o">.</span><span class="n">orbs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="IntegralFeed.atomic_block_indices">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed.atomic_block_indices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">atomic_block_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomic_idx_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">atomic_idx_2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
                             <span class="n">orbs</span><span class="p">:</span> <span class="n">OrbitalInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the indices of the specified blocks.</span>

<span class="sd">        This method identifies the blocks associated with the specified atom</span>
<span class="sd">        pairs and returns the indexing arrays that can be used to retrieve</span>
<span class="sd">        said blocks.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            atomic_idx_1: Atomic indices of the 1&#39;st atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            atomic_idx_2: Atomic indices of the 2&#39;nd atom associated with each</span>
<span class="sd">                desired interaction block.</span>
<span class="sd">            orbs: Orbital information associated with said systems.</span>

<span class="sd">        Returns:</span>
<span class="sd">            block_indices: the indices of the specified blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_batch</span> <span class="o">=</span> <span class="n">atomic_idx_1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Indices must be provided as torch tensors not numpy arrays&quot;</span><span class="p">)</span>
            <span class="n">atomic_idx_1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">)</span>
            <span class="n">atomic_idx_2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)</span>

        <span class="c1"># Block indices are mostly used in their transposed form</span>
        <span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span> <span class="o">=</span> <span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_1</span><span class="p">),</span> <span class="n">bT</span><span class="p">(</span><span class="n">atomic_idx_2</span><span class="p">)</span>

        <span class="c1"># Non-batch tensors must be inflated to permit batch agnosticism</span>
        <span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">idx_i</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">idx_j</span><span class="p">)</span>

        <span class="c1"># Find the index at which each atomic block starts.</span>
        <span class="n">blk_starts</span> <span class="o">=</span> <span class="p">(</span><span class="n">opa</span> <span class="o">:=</span> <span class="n">orbs</span><span class="o">.</span><span class="n">orbs_per_atom</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">opa</span>

        <span class="c1"># Row/column offset template; used to build the indices specifying</span>
        <span class="c1"># the location of a block&#39;s elements in the target matrix.</span>
        <span class="c1"># The internal list comprehension just gets the number of orbitals</span>
        <span class="c1"># present on the first and second atoms.</span>
        <span class="n">rt</span><span class="p">,</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">indices</span><span class="p">((</span><span class="n">opa</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="n">idx_j</span><span class="p">]),</span>
                         <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Get the block&#39;s row &amp; column indices.</span>
        <span class="n">blk_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">rt</span> <span class="o">+</span> <span class="n">blk_starts</span><span class="p">[</span><span class="o">*</span><span class="n">idx_i</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                               <span class="n">ct</span> <span class="o">+</span> <span class="n">blk_starts</span><span class="p">[</span><span class="o">*</span><span class="n">idx_j</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">is_batch</span><span class="p">:</span>  <span class="c1"># Add bach indices, if appropriate.</span>
            <span class="n">b_idx</span> <span class="o">=</span> <span class="n">idx_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">blk_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">bT</span><span class="p">(</span><span class="n">b_idx</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="o">*</span><span class="n">rt</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">blk_idx</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">blk_idx</span></div>


<div class="viewcode-block" id="IntegralFeed.to">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed.to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;IntegralFeed&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a copy of the `SkFeed` instance on the specified device.</span>

<span class="sd">        This method creates and returns a new copy of the `SkFeed` instance</span>
<span class="sd">        on the specified device &quot;``device``&quot;.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            device: Device on which the clone should be placed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sk_feed: A copy of the `SkFeed` instance placed on the specified</span>
<span class="sd">                device.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If the `SkFeed` instance is already on the desired device then</span>
<span class="sd">            `self` will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="IntegralFeed.load">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed.load">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Group</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;IntegralFeed&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load a stored integral feed object.</span>

<span class="sd">        This is only for loading preexisting ``IntegralFeed`` objects, from</span>
<span class="sd">        HDF5 databases, not instantiating new ones.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            source: Name of a file to load the integral feed from or an HDF5</span>
<span class="sd">                group from which it can be extracted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ski_feed: A ``IntegralFeed`` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="IntegralFeed.save">
<a class="viewcode-back" href="../../../_autosummary/tbmalt.ml.integralfeeds.IntegralFeed.html#tbmalt.ml.integralfeeds.IntegralFeed.save">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Group</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the integral feed to an HDF5 database.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            target: Name of a file to save the integral feed to or an HDF5</span>
<span class="sd">                group in which it can be saved.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If `target` is a string then a new HDF5 database will be created</span>
<span class="sd">            at the path specified by the string. If an HDF5 entity was given</span>
<span class="sd">            then a new HDF5 group will be created and added to it.</span>

<span class="sd">            Under no circumstances should this just pickle an object. Doing so</span>
<span class="sd">            is unstable, unsafe and inflexible.</span>

<span class="sd">            It is good practice to save the name of the class so that the code</span>
<span class="sd">            automatically knows how to unpack it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Create a HDF5 database and save the feed to it</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
            <span class="c1"># Create a new group, save the feed in it and add it to the Group</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, TBMaLT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>