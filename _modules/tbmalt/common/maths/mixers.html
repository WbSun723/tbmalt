

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tbmalt.common.maths.mixers &mdash; TBMaLT 0.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=7026087e"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            TBMaLT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">1. Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html">2. Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">3. Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../development.html">4. Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide.html">5. Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release_notes.html">6. Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">TBMaLT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../common.html">tbmalt.common</a></li>
          <li class="breadcrumb-item"><a href="../maths.html">tbmalt.common.maths</a></li>
      <li class="breadcrumb-item active">tbmalt.common.maths.mixers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tbmalt.common.maths.mixers</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;A selection of mixing algorithms for aiding and accelerating convergence.</span>

<span class="sd">This module contains a selection of different mixing algorithms. These methods</span>
<span class="sd">can be used to accelerate and/or stabilise the convergence of fixed-point</span>
<span class="sd">iterations. Within the context of TBMaLT, these are intended to help converge</span>
<span class="sd">the self-consistent-field/charge (SCF/SCC) cycles.</span>

<span class="sd">In the majority of cases it is fundamentally impossible to identify from the</span>
<span class="sd">input alone whether the user is attempting to mix a single system or a batch</span>
<span class="sd">of such systems. This an ambiguity renders the shape-agnostic &amp; batch-agnostic</span>
<span class="sd">programming paradigms incompatible with one another. As such one paradigm must</span>
<span class="sd">be abandoned in favor of the other. Thus, all mixing instances require the</span>
<span class="sd">user to explicitly state whether they are operating on a single system or on a</span>
<span class="sd">batch of systems.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">prod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tensor</span>


<div class="viewcode-block" id="Mixer">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Mixer.html#tbmalt.common.maths.mixers.Mixer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Mixer</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the abstract base class upon which all mixers are to be based.</span>

<span class="sd">    This abstract base class provides the template on which all mixers are to</span>
<span class="sd">    be built.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        is_batch: Set to true when mixing a batch of systems, False when not.</span>
<span class="sd">        tolerance: Max permitted difference in between successive iterations</span>
<span class="sd">            for a system to be considered &quot;converged&quot;. [DEFAULT=1E-6]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_batch</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1E-6</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="o">=</span> <span class="n">is_batch</span>

        <span class="c1"># Integer tracking the number of mixing iterations performed thus far.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Difference between the current &amp; previous systems</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_tolerance_threshold_check</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Wrapper to check the validity of the current tolerance value.</span>

<span class="sd">            This wraps `__call__` to ensure that a tolerance threshold check</span>
<span class="sd">            gets carried out on the first call, i.e. when `_step_number` is</span>
<span class="sd">            zero. If the specified tolerance cannot be achieved then a warning</span>
<span class="sd">            will be issued and the tolerance will be downgraded to just below</span>
<span class="sd">            the precision limit.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># pylint: disable=W0212</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
                    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">resolution</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">: Tolerance value &#39;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="si">}</span><span class="s2"> can&#39;t be achieved by a </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="s1">&#39;. DOWNGRADING!&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">resolution</span> <span class="o">*</span> <span class="mf">5.0</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">wrapper</span>

        <span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span> <span class="o">=</span> <span class="n">_tolerance_threshold_check</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Conducts any required initialisation operations.</span>

<span class="sd">        Any setup code that needs only to be once, during the first call to</span>
<span class="sd">        &quot;`__call__`&quot; is placed here. This abstraction helps to clean up the</span>
<span class="sd">        `__call__` function by removing any code that is not needed for the</span>
<span class="sd">        mixing operation.</span>

<span class="sd">        Notes:</span>
<span class="sd">            It is expected that new mixer classes will locally override this</span>
<span class="sd">            function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">x_old</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs the mixing operation &amp; returns the newly mixed system.</span>

<span class="sd">        This should contain only the code required to carry out the mixing</span>
<span class="sd">        operation.</span>

<span class="sd">        Notes:</span>
<span class="sd">            In all implementations the `x_new` argument **MUST** be the first</span>
<span class="sd">            non-self argument, x_old should be an optional keyword argument.</span>
<span class="sd">            The first call to this function, i.e. when `self._step_number` is</span>
<span class="sd">            zero, should make a call to `_setup_hook`, if applicable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns representative string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">step_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Integer tracking the number of mixing iterations performed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">converged</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tensor of bools indicating convergence status of the system(s).</span>

<span class="sd">        A system is considered to have converged if the maximum absolute</span>
<span class="sd">        difference between the current and previous systems is less than</span>
<span class="sd">        the ``tolerance`` value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The return type is set as Union[Tensor, bool] to aid type-checking.</span>
        <span class="c1"># Check that mixing has been conducted</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Nothing has been mixed&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span><span class="p">:</span>  <span class="c1"># If not in batch mode</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># If operating in batch mode</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Catch needed when operating on a batch of scalars.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                                           <span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Difference between the current &amp; previous systems&quot;&quot;&quot;</span>
        <span class="c1"># This may need to be locally overridden if &quot;_delta&quot; needs to be</span>
        <span class="c1"># reshaped prior to it being returned.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span>

<div class="viewcode-block" id="Mixer.reset">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Mixer.html#tbmalt.common.maths.mixers.Mixer.reset">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resets the mixer to its initial state.&quot;&quot;&quot;</span>
        <span class="c1"># This should reset all attributes like, _step_count, _delta, etc.</span>
        <span class="c1"># Effectively placing the mixer instance into the state it was in</span>
        <span class="c1"># prior to the first mixing operation.</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="Mixer.cull">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Mixer.html#tbmalt.common.maths.mixers.Mixer.cull">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cull_list</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
             <span class="n">new_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Purge select systems form the mixer.</span>

<span class="sd">        This is useful when a subset of systems have converged during mixing.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            cull_list: Tensor with booleans indicating which systems should be</span>
<span class="sd">                culled (True) and which should remain (False).</span>

<span class="sd">            new_size: New anticipated size of future inputs excluding the batch</span>
<span class="sd">                dimension. This is used to allow superfluous padding values to</span>
<span class="sd">                be removed form subsequent inputs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This code should carry out all the operations necessary to remove a</span>
        <span class="c1"># system from the mixer. All mixing operations after this point should</span>
        <span class="c1"># mix only the remaining systems. This function should check that</span>
        <span class="c1"># &quot;is_batch&quot; is True first; as it makes no sense to attempt a cull</span>
        <span class="c1"># when not in batch mode.</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="Simple">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Simple.html#tbmalt.common.maths.mixers.Simple">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Simple</span><span class="p">(</span><span class="n">Mixer</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Simple linear mixer mixing algorithm.</span>

<span class="sd">    Iteratively mixes pairs of systems via a simple linear combination:</span>

<span class="sd">    .. math::</span>

<span class="sd">        (1-f)x_n + fx_{n-1}</span>

<span class="sd">    Where :math:`x_n`/:math:`x_{n-1}` are the new/old systems respectively &amp;</span>
<span class="sd">    :math:`f` is the mixing parameter, i.e. the fraction of :math:`x_n` that</span>
<span class="sd">    is to be retained. Given a suitable tolerance, and a small enough mixing</span>
<span class="sd">    parameter, the `Simple` mixer is guaranteed to converge, however, it also</span>
<span class="sd">    tends to be significantly slower than other, more advanced, methods.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        is_batch: Set to true when mixing a batch of systems, False when not.</span>
<span class="sd">        mix_param: Mixing parameter, ∈(0, 1), controls the extent of mixing.</span>
<span class="sd">            Larger values result in more aggressive mixing. [DEFAULT=0.05]</span>
<span class="sd">        tolerance: Maximum permitted difference in charge between successive</span>
<span class="sd">            iterations for a system to be considered &quot;converged&quot;.</span>

<span class="sd">    Notes:</span>
<span class="sd">        Mixer instances require the user to explicitly specify during</span>
<span class="sd">        initialisation whether it is a single system or a batch of systems</span>
<span class="sd">        that are to be mixed.</span>

<span class="sd">    Examples:</span>
<span class="sd">        More in-depth examples of mixing algorithms can be found in the</span>
<span class="sd">        tutorial section of the documentation.</span>

<span class="sd">        The attractive fixed point of the function:</span>

<span class="sd">        &gt;&gt;&gt; from torch import tensor, sqrt</span>
<span class="sd">        &gt;&gt;&gt; def func(x):</span>
<span class="sd">        &gt;&gt;&gt;     return tensor([0.5 * sqrt(x[0] + x[1]),</span>
<span class="sd">        &gt;&gt;&gt;                    1.5 * x[0] + 0.5 * x[1]])</span>

<span class="sd">        can be idenfied using the ``Simple`` mixer as follows:</span>

<span class="sd">        &gt;&gt;&gt; from tbmalt.common.maths.mixers import Simple</span>
<span class="sd">        &gt;&gt;&gt; x = tensor([2., 2.])  # Initial guess</span>
<span class="sd">        &gt;&gt;&gt; mixer = Simple(False, tolerance=1E-4, mix_param=0.8)</span>
<span class="sd">        &gt;&gt;&gt; for i in range(100):</span>
<span class="sd">        &gt;&gt;&gt;     x = mixer(func(x), x)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">            &gt;&gt;&gt; # tensor([1., 3.])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_batch</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">mix_param</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
                 <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1E-6</span><span class="p">):</span>
        <span class="c1"># Pass required inputs to parent class.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">is_batch</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mix_param</span> <span class="o">=</span> <span class="n">mix_param</span>

        <span class="c1"># Holds the system from the previous iteration.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_old</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;NullOp to satisfy abstractmethod requirement so parent class.</span>

<span class="sd">        The simple mixer is unique in that it does not require any setup. Thus</span>
<span class="sd">        an empty function has been created to satisfy the requirements of the</span>
<span class="sd">        parent class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">x_old</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs the simple mixing operation &amp; returns the mixed system.</span>

<span class="sd">        Iteratively mix pairs of systems via a simple linear combination:</span>

<span class="sd">        .. math::</span>

<span class="sd">            (1-f)x_n + fx_{n-1}</span>

<span class="sd">        Arguments:</span>
<span class="sd">            x_new: New system(s) that is to be mixed.</span>
<span class="sd">            x_old: Previous system(s) that is to be mixed. Only required for</span>
<span class="sd">                the first mix operation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            x_mix: Newly mixed system(s).</span>

<span class="sd">        Notes:</span>
<span class="sd">            The ``x_old`` argument is normally identical to the ``x_mix``</span>
<span class="sd">            value returned from the previous iteration, which is stored by the</span>
<span class="sd">            class internally. As such, the ``x_old`` argument can be omitted</span>
<span class="sd">            from all but the first step if desired.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Increment the step number variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Use the previous x_old value if none was specified</span>
        <span class="n">x_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_old</span> <span class="k">if</span> <span class="n">x_old</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x_old</span>

        <span class="c1"># Safety check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;Batch dimension of x_new and x_old do not match; ensure &#39;</span>
                    <span class="s1">&#39;calls are made to mixer.cull as needed.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">x_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Non-batch dimension mismatch encountered - x_new &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x_new</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">, x_old </span><span class="si">{</span><span class="n">x_old</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">; this may result &#39;</span>
                    <span class="s1">&#39;from a failure provide a &quot;new_size&quot; arg to mixer.cull.&#39;</span>
                <span class="p">)</span>

        <span class="c1"># Check all tensor dimensions match</span>
        <span class="k">assert</span> <span class="n">x_old</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x_new</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>\
            <span class="s1">&#39;new &amp; old systems must have matching shapes.&#39;</span>

        <span class="c1"># Perform the mixing operation to create the new mixed x value</span>
        <span class="n">x_mix</span> <span class="o">=</span> <span class="n">x_old</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_old</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mix_param</span>

        <span class="c1"># Update the _x_old attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_old</span> <span class="o">=</span> <span class="n">x_mix</span>

        <span class="c1"># Update the delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_old</span><span class="p">)</span>

        <span class="c1"># Return the newly mixed system</span>
        <span class="k">return</span> <span class="n">x_mix</span>

<div class="viewcode-block" id="Simple.reset">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Simple.html#tbmalt.common.maths.mixers.Simple.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resets the mixer to its initial state.</span>

<span class="sd">        Calling this function will rest the class &amp; its internal attributes.</span>
<span class="sd">        However, any properties set during the initialisation process, e.g.</span>
<span class="sd">        ``mix_param``, ``threshold``, etc. will be retained.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset the step_number, delta, and x_old parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_old</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Simple.cull">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Simple.html#tbmalt.common.maths.mixers.Simple.cull">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cull_list</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
             <span class="n">new_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Purge select systems form the mixer.</span>

<span class="sd">        This is useful when a subset of systems that have converged during</span>
<span class="sd">        mixing.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            cull_list: Tensor with booleans indicating which systems should be</span>
<span class="sd">                culled (True) and which should remain (False).</span>
<span class="sd">            new_size: New anticipated size of future inputs excluding the batch</span>
<span class="sd">                dimension. This is used to allow superfluous padding values to</span>
<span class="sd">                be removed form subsequent inputs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span><span class="p">,</span> <span class="s1">&#39;Cull only valid for batch mixing&#39;</span>

        <span class="c1"># If a new size has been provided then cut the properties down to size</span>
        <span class="c1"># so to remove superfluous padding values.</span>
        <span class="k">if</span> <span class="n">new_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slicers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_size</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slicers</span> <span class="o">=</span> <span class="p">(</span><span class="o">...</span><span class="p">,)</span>

        <span class="c1"># Invert cull_list, gather &amp; reassign x_old and _delta so only those</span>
        <span class="c1"># marked False remain.</span>
        <span class="n">cull</span> <span class="o">=</span> <span class="o">~</span><span class="n">cull_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_old</span><span class="p">[[</span><span class="n">cull</span><span class="p">,</span> <span class="o">*</span><span class="n">slicers</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="p">[[</span><span class="n">cull</span><span class="p">,</span> <span class="o">*</span><span class="n">slicers</span><span class="p">]]</span></div>
</div>



<div class="viewcode-block" id="Anderson">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Anderson.html#tbmalt.common.maths.mixers.Anderson">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Anderson</span><span class="p">(</span><span class="n">Mixer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Accelerated Anderson mixing algorithm.</span>

<span class="sd">    Anderson acceleration is a method for accelerating convergence of fixed</span>
<span class="sd">    point iterations. Upon instantiation, a callable instance will be</span>
<span class="sd">    returned. Calls to this instance will take, as its arguments, two input</span>
<span class="sd">    systems and will return a single mixed system.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        is_batch: Set to true when mixing a batch of systems, False when not.</span>
<span class="sd">        mix_param: Mixing parameter, ∈(0, 1), controls the extent of mixing.</span>
<span class="sd">            Larger values result in more aggressive mixing. [DEFAULT=0.05]</span>
<span class="sd">        tolerance: Maximum permitted difference in charge between successive</span>
<span class="sd">            iterations for a system to be considered &quot;converged&quot;.</span>
<span class="sd">        generations: Number of generations to use during mixing. [DEFAULT=4]</span>
<span class="sd">        diagonal_offset: Offset added to the equation system&#39;s diagonal&#39;s</span>
<span class="sd">            to prevent a linear dependence during the mixing process. If set</span>
<span class="sd">            to `None` then rescaling will be disabled. [DEFAULT=0.01]</span>
<span class="sd">        init_mix_param: Mixing parameter to use during the initial simple</span>
<span class="sd">            mixing steps. [DEFAULT=0.01]</span>
<span class="sd">        soft_start: If enabled, then simple mixing will be used for the first</span>
<span class="sd">            ``generations`` number of steps, otherwise only for the first.</span>
<span class="sd">            [DEFAULT=False]</span>

<span class="sd">    Notes:</span>
<span class="sd">        Note that simple mixing will always be used for the first step. If</span>
<span class="sd">        ``soft_start`` is enabled then the simple mixer will also be used for</span>
<span class="sd">        the following ``generations``-1 steps.</span>

<span class="sd">        The Anderson mixing functions primarily follow the equations set out</span>
<span class="sd">        by Eyert [Eyert]_. However, this code borrows heavily from the DFTB+</span>
<span class="sd">        implementation [DFTB]_. This deviates from the DFTB+ implementation</span>
<span class="sd">        in that it does not compute or use the theta zero values, as they</span>
<span class="sd">        cause stability issues in this implementation. For more information on</span>
<span class="sd">        Anderson mixing see See &quot;Anderson Acceleration, Mixing and</span>
<span class="sd">        Extrapolation&quot; [Anderson]_.</span>

<span class="sd">    Warnings:</span>
<span class="sd">        Setting ``generations`` too high can lead to a linearly dependent set</span>
<span class="sd">        of equations. However, this effect can be mitigated through the use of</span>
<span class="sd">        the ``diagonal_offset`` parameter.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [Eyert] Eyert, V. (1996). A Comparative Study on Methods for</span>
<span class="sd">           Convergence Acceleration of Iterative Vector Sequences. Journal of</span>
<span class="sd">           Computational Physics, 124(2), 271–285.</span>
<span class="sd">        .. [DFTB] Hourahine, B., Aradi, B., Blum, V., Frauenheim, T. et al.,</span>
<span class="sd">           (2020). DFTB+, a software package for efficient approximate density</span>
<span class="sd">           functional theory based atomistic simulations. The Journal of</span>
<span class="sd">           Chemical Physics, 152(12), 124101.</span>
<span class="sd">        .. [Anderson] Anderson, D. M. (2018). Comments on “Anderson</span>
<span class="sd">           Acceleration, Mixing and Extrapolation.” Numerical Algorithms,</span>
<span class="sd">           80(1), 135–234.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_batch</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">mix_param</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
                 <span class="n">generations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">diagonal_offset</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                 <span class="n">init_mix_param</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1E-6</span><span class="p">,</span>
                 <span class="n">soft_start</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">is_batch</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mix_param</span> <span class="o">=</span> <span class="n">mix_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generations</span> <span class="o">=</span> <span class="n">generations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_mix_param</span> <span class="o">=</span> <span class="n">init_mix_param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_offset</span> <span class="o">=</span> <span class="n">diagonal_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soft_start</span> <span class="o">=</span> <span class="n">soft_start</span>

        <span class="c1"># Holds &quot;x&quot; history and &quot;x&quot; delta history</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Systems are flatted during input to permit shape agnostic</span>
        <span class="c1"># programming. The shape information is stored here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform post instantiation initialisation operation.</span>

<span class="sd">        This instantiates internal variables.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            x_new: New system(s) that is to be mixed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtype</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="n">x_new</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">x_new</span><span class="o">.</span><span class="n">device</span>

        <span class="c1"># Tensors are converted to _shape_in when passed in and back to their</span>
        <span class="c1"># original shape _shape_out when returned to the user.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_new</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x_new</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Instantiate the x history (x_hist) and the delta history &#39;d_hist&#39;</span>
        <span class="c1"># The current step is also stored hence &quot;self.generations + 1&quot;.</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generations</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Difference between the current &amp; previous systems&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_out</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">x_old</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform Anderson mixing operation.</span>

<span class="sd">        This takes a new system ``x_new`` &amp; uses its past history to generate</span>
<span class="sd">        a new &quot;mixed&quot; system via the anderson method.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            x_new: New system(s) that is to be mixed.</span>
<span class="sd">            x_old: Previous system(s) that is to be mixed. Only required for</span>
<span class="sd">                the first mix operation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            x_mix: Newly mixed system(s).</span>

<span class="sd">        Notes:</span>
<span class="sd">            Simple mixing will be used for the first n steps, where n is the</span>
<span class="sd">            number of previous steps to be use in the mixing process.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># At some point a check should be put in place to give a more useful</span>
        <span class="c1"># error when the user padding values from new inputs without providing</span>
        <span class="c1"># a new_size argument during calls to the cull method.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Call setup hook if this is the 1st cycle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setup_hook</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_old</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment step_number</span>

        <span class="c1"># Following Eyert&#39;s notation, &quot;f&quot; refers to the delta:</span>
        <span class="c1">#   F = x_new - x_old</span>
        <span class="c1"># However, for clarity &quot;x_hist&quot; is used in place of Eyert&#39;s &quot;x&quot;.</span>

        <span class="c1"># Inputs must be reshaped to ensure they a vector (or batch thereof)</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="n">x_new</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span><span class="p">)</span>

        <span class="c1"># If x_old specified; overwrite last entry in self._x_hist.</span>
        <span class="n">x_old</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">x_old</span> <span class="ow">is</span> <span class="kc">None</span>
                 <span class="k">else</span> <span class="n">x_old</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span><span class="p">))</span>

        <span class="c1"># Calculate x_new - x_old delta &amp; assign to the delta history _f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_new</span> <span class="o">-</span> <span class="n">x_old</span>

        <span class="c1"># If a sufficient history has been built up then use Anderson mixing</span>
        <span class="c1"># if self._step_number &gt; self.generations:</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">generations</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_number</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">soft_start</span><span class="p">):</span>

            <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step_number</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generations</span><span class="p">)</span>
            <span class="c1"># Setup and solve the linear equation system, as described in</span>
            <span class="c1"># equation 4.3 (Eyert), to get the coefficients &quot;thetas&quot;:</span>
            <span class="c1">#   a(i,j) =  &lt;F(l) - F(l-i)|F(l) - F(l-j)&gt;</span>
            <span class="c1">#   b(i)   =  &lt;F(l) - F(l-i)|F(l)&gt;</span>
            <span class="c1"># here dF = &lt;F(l) - F(l-i)|</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i...v,j...v-&gt;...ij&#39;</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;h...v,...v-&gt;...h&#39;</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Rescale diagonals to prevent linear dependence on the residual</span>
            <span class="c1"># vectors by adding 1 + offset^2 to the diagonals of &quot;a&quot;, see</span>
            <span class="c1"># equation 8.2 (Eyert)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a_scaled_diag</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">dim1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                                 <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_offset</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

                <span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">dim1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_scaled_diag</span>

            <span class="c1"># Solve for the coefficients. As torch.solve cannot solve for 1D</span>
            <span class="c1"># tensors a blank dimension must be added</span>
            <span class="n">thetas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))))</span>

            <span class="c1"># Construct the 2&#39;nd terms of eq 4.1 &amp; 4.2 (Eyert). These are</span>
            <span class="c1"># the &quot;averaged&quot; histories of x and F respectively:</span>
            <span class="c1">#   x_bar = sum(j=1 -&gt; m) ϑ_j(l) * (|x(l-j)&gt; - |x(l)&gt;)</span>
            <span class="c1">#   f_bar = sum(j=1 -&gt; m) ϑ_j(l) * (|F(l-j)&gt; - |F(l)&gt;)</span>
            <span class="c1"># These are not the x_bar &amp; F_var values of eq. 4.1 &amp; 4.2 (Eyert)</span>
            <span class="c1"># yet as they are still missing the 1st terms.</span>
            <span class="n">x_bar</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...h,h...v-&gt;...v&#39;</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">f_bar</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...h,h...v-&gt;...v&#39;</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>

            <span class="c1"># Add in the first term</span>
            <span class="n">x_bar</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f_bar</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Calculate the new mixed dQ following equation 4.4 (Eyert):</span>
            <span class="c1">#   |x(l+1)&gt; = |x_bar(l)&gt; + beta(l)|f_bar(l)&gt;</span>
            <span class="c1"># where &quot;beta&quot; is the mixing parameter</span>
            <span class="n">x_mix</span> <span class="o">=</span> <span class="n">x_bar</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mix_param</span> <span class="o">*</span> <span class="n">f_bar</span><span class="p">)</span>

        <span class="c1"># If there is insufficient history for Anderson; use simple mixing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_mix_param</span><span class="p">)</span>

        <span class="c1"># Shift f &amp; x_hist over; a roll follow by a reassignment is</span>
        <span class="c1"># necessary to avoid an inplace error. (gradients remain intact)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Assign the mixed x to the x_hist history array. The last x_mix value</span>
        <span class="c1"># is saved on the assumption that it will be used in the next step.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_mix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Save the last difference to _delta</span>

        <span class="c1"># Reshape the mixed system back into the expected shape and return it</span>
        <span class="k">return</span> <span class="n">x_mix</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_out</span><span class="p">)</span>

<div class="viewcode-block" id="Anderson.cull">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Anderson.html#tbmalt.common.maths.mixers.Anderson.cull">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cull</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cull_list</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
            <span class="n">new_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Purge select systems form the mixer.</span>

<span class="sd">        This is useful when a subset of systems have converged during mixing.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            cull_list: Tensor with booleans indicating which systems should be</span>
<span class="sd">                culled (True) and which should remain (False).</span>
<span class="sd">            new_size: New anticipated size of future inputs excluding the batch</span>
<span class="sd">                dimension. This is used to allow superfluous padding values to</span>
<span class="sd">                be removed form subsequent inputs.</span>

<span class="sd">        Warning:</span>
<span class="sd">            The current size only works for 2D batch system.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_batch</span><span class="p">,</span> <span class="s1">&#39;Cull only valid for batch mixing&#39;</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">new_size</span> <span class="k">if</span> <span class="n">new_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape_out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Length of flattened arrays after factoring in the new</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Invert the cull_list, gather &amp; reassign self._delta self._x_hist &amp;</span>
        <span class="c1"># self._f so only those marked False remain.</span>
        <span class="n">cull</span> <span class="o">=</span> <span class="o">~</span><span class="n">cull_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="p">[</span><span class="n">cull</span><span class="p">,</span> <span class="p">:</span><span class="n">l</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[:,</span> <span class="n">cull</span><span class="p">,</span> <span class="p">:</span><span class="n">l</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span><span class="p">[:,</span> <span class="n">cull</span><span class="p">,</span> <span class="p">:</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># Adjust the the shapes accordingly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cull_list</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_out</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">shape</span><span class="p">]</span></div>


<div class="viewcode-block" id="Anderson.reset">
<a class="viewcode-back" href="../../../../_autosummary/tbmalt.common.maths.mixers.Anderson.html#tbmalt.common.maths.mixers.Anderson.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset mixer to its initial state.&quot;&quot;&quot;</span>
        <span class="c1"># Reset all internal attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape_out</span> <span class="o">=</span> <span class="kc">None</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, TBMaLT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>